// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var CND, PD, alert, badge, debug, help, info, rpr, urge, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'æ˜Žå¿«æ‰“å­—æœº/OPS-CM';

  debug = CND.get_logger('debug', badge);

  alert = CND.get_logger('alert', badge);

  whisper = CND.get_logger('whisper', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  info = CND.get_logger('info', badge);

  //...........................................................................................................
  PD = require('pipedreams');

  //-----------------------------------------------------------------------------------------------------------
  this._cm_as_pos = function(x) {
    return {
      line: x.line,
      ch: x.ch
    };
  };

  //-----------------------------------------------------------------------------------------------------------
  this./* Unify position-like objects */_cm_order_positions = function(positions) {
    return positions.sort(function(a, b) {
      if (a.line < b.line) {
        return -1;
      }
      if (a.line > b.line) {
        return +1;
      }
      if (a.ch < b.ch) {
        return -1;
      }
      if (a.ch > b.ch) {
        return +1;
      }
      return 0;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._cm_fromto_from_range = function(range) {
    /* Given a `range` with `anchor` and `head` properties (which must both be positions, i.e.
    `{ line, ch, }` objects), return a `{ from, to, }` object where `from` comes always before or coincides
    with `to` in the document. This is needed to convert an object returned e.g. as selection to an
    argument that can be used by `markText()`. */
    var p, q;
    [p, q] = this._cm_order_positions([this._cm_as_pos(range.anchor), this._cm_as_pos(range.head)]);
    return {
      from: p,
      to: q
    };
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.cm_select_all = function() {
    return CodeMirror.commands.selectAll(S.codemirror.editor);
  };

  this.cm_select_only_first = function() {
    return CodeMirror.commands.singleSelection(S.codemirror.editor);
  };

  this.cm_get_selections = function() {
    return S.codemirror.editor.doc.listSelections();
  };

  this.cm_get_selection_texts = function() {
    return S.codemirror.editor.doc.getSelections();
  };

  this.cm_get_selections_as_fromtos = function() {
    var i, len, ref, results, s;
    ref = this.cm_get_selections();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      s = ref[i];
      results.push(this._cm_fromto_from_range(s));
    }
    return results;
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @cm_select_only_in_single_line = ->

  //-----------------------------------------------------------------------------------------------------------
  this.cm_set_mark = function(fromto, clasz) {
    var settings;
    this.log('Âµ52981', `@cm_set_mark ${rpr(fromto)}, ${rpr(clasz)}`);
    settings = {
      className: clasz,
      inclusiveLeft: true,
      inclusiveRight: true
    };
    return S.codemirror.editor.markText(fromto.from, fromto.to, settings);
  };

  //-----------------------------------------------------------------------------------------------------------
  // @cm_clear_translation_mark = ->
  //   return 0 unless S.translation_mark?
  //   S.translation_mark.clear()
  //   S.translation_mark = null
  //   return 1

  //-----------------------------------------------------------------------------------------------------------
  this.cm_get_marks_in_range = function(fromto) {
    return S.codemirror.editor.findMarks(fromto.from, fromto.to);
  };

  this.cm_get_mark_fromtos_in_range = function(fromto) {
    var i, len, ref, results, t;
    ref = this.cm_get_marks_in_position(fromto);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      t = ref[i];
      results.push(this._cm_as_pos(t.find()));
    }
    return results;
  };

  this.cm_get_marks_in_position = function(position) {
    return S.codemirror.editor.findMarksAt(position);
  };

  this.cm_get_cursor = function() {
    return this._cm_as_pos(S.codemirror.editor.getCursor('head'));
  };

  this.cm_set_cursor = function(position) {
    return S.codemirror.editor.setCursor(position);
  };

  this./* TAINT might want to use options */cm_get_text = function(fromto) {
    return S.codemirror.editor.getRange(fromto.from, fromto.to);
  };

  this.cm_text_from_mark = function(mark) {
    return this.cm_get_text(mark.find());
  };

  this.cm_text_from_line_idx = function(line_idx) {
    return S.codemirror.editor.getLine(line_idx);
  };

  this.cm_replace_selection = function(text) {
    return S.codemirror.editor.doc.replaceSelection(text);
  };

  this.cm_range_is_point = function(fromto) {
    return CND.equals(fromto.from, fromto.to);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.cm_select = function(fromto) {
    this.log('Âµ53082', `cm_select: ${rpr(fromto)}`);
    return S.codemirror.editor.setSelection(fromto.from, fromto.to);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.position_and_clasz_from_mark = function(mark) {
    var fromto, ref;
    fromto = mark.find();
    return {
      from: this._cm_as_pos(fromto.from),
      to: this._cm_as_pos(fromto.to),
      clasz: (ref = mark.className) != null ? ref : ''
    };
  };

  //===========================================================================================================
  // SET TSRs, TRANSCRIPTORS
  //-----------------------------------------------------------------------------------------------------------
  this.cm_set_tsrs_NG = function(tsnr) {
    /* Bound to `ctrl+0` ... `ctrl+4` */
    var action, clasz, delta, fromto, fromto_right, i, len, ref, settings, tsr_mark_left;
    action = tsnr === 0 ? 'clear' : 'set';
    if (action === 'clear') {
      this.log('Âµ48733-1', "clear TSR not implemented");
      return null;
    }
    delta = action === 'clear' ? -1 : +1;
    clasz = `tsr tsr${tsnr}`;
    ref = this.cm_get_selections_as_fromtos();
    for (i = 0, len = ref.length; i < len; i++) {
      fromto = ref[i];
      if (!this.cm_range_is_point(fromto)) {
        this.log('Âµ48733-2', "non-point ranges not implemented");
        return null;
      }
      this.log('Âµ48733-4', rpr(fromto));
      /* TAINT use own API */
      /* TAINT allow to configure appearance of TSR mark */
      // tsr_mark_left = "[#{S.transcriptors[ tsnr ].display_name}:"
      tsr_mark_left = `ðŸ›¸${tsnr}:`;
      clasz = `tsrNG tsrNG${tsnr}`;
      fromto_right = {
        line: fromto.from.line,
        ch: fromto.from.ch + tsr_mark_left.length
      };
      settings = {
        className: clasz,
        atomic: true,
        inclusiveLeft: false,
        inclusiveRight: false
      };
      S.codemirror.editor.replaceRange(tsr_mark_left, fromto.from);
      S.codemirror.editor.markText(fromto.from, fromto_right, settings);
    }
    S.emit_transcribe_event_NG();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.emit_transcribe_event_NG = function() {
    var match, text;
    text = this.cm_text_from_line_idx(this.cm_get_cursor().line);
    if (text.length === 0) {
      return null;
    }
    if ((match = text.match(/ðŸ›¸(?<tsnr>[0-9]+):(?<text>[.*?])$/)) == null) {
      return;
    }
    this.log('Âµ76663', rpr(match.groups));
    return null;
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @cm_set_tsrs = ( tsnr ) ->
  //   ### Bound to `ctrl+0` ... `ctrl+4` ###
  //   ### TAINT code duplication ###
  //   # @cm_select_only_in_single_line()
  //   # @cm_clear_translation_mark()
  //   action  = if tsnr is 0 then 'clear' else 'set'
  //   delta   = if action is 'clear' then -1 else +1
  //   clasz   = "tsr tsr#{tsnr}"
  //   count   = 0
  //   for fromto in @cm_get_selections_as_fromtos()
  //     range_is_point = @cm_range_is_point fromto
  //     if range_is_point then  old_marks = @cm_get_marks_in_position  fromto.from
  //     else                    old_marks = @cm_get_marks_in_range     fromto
  //     for old_mark in old_marks
  //       do ( old_mark ) =>
  //         @log 'Âµ53183', "found old mark: #{rpr @position_and_clasz_from_mark old_mark}"
  //         old_mark.clear()
  //     if action is 'set'
  //       if range_is_point
  //         ### TAINT use own API ###
  //         S.codemirror.editor.replaceRange '\ue044', fromto.from
  //         fromto1 = { from: fromto.from, to: { line: fromto.from.line, ch: ( fromto.from.ch + 1 ), }, }
  //         @cm_select fromto1
  //         mark    = @cm_set_mark fromto1, clasz
  //       else
  //         ### TAINT trailing newlines, empty lines are probably a bad idea; if CodeMirror would only visibly
  //         mark those, but it doesn't ###
  //         if ( nl_count = ( ( @cm_get_text fromto ).match /(\n*)$/ )[ 1 ].length ) > 0
  //           @log 'Âµ53284', "fromto #{rpr fromto} contains empty lines"
  //         mark = @cm_set_mark fromto, clasz
  //       ### TAINT this is doing too much work for this case: ###
  //       @emit_transcribe_event()
  //   return count

  // #-----------------------------------------------------------------------------------------------------------
  // @emit_transcribe_event = ->
  //   ### Called on CM `CursorActivity`, reads text from current TSR if any, emits XE `^transcribe` ###
  //   # @log 'Âµ53486', 'cm_find_ts', "cursor at #{rpr @cm_get_cursor()}"
  //   marks = @cm_get_marks_in_position @cm_get_cursor()
  //   #.........................................................................................................
  //   if marks.length is 0
  //     S.tsnr          = 0
  //     S.tsr           = null
  //     S.tsr_text      = null
  //     S.transcriptor  = S.transcriptors[ 0 ]
  //   #.........................................................................................................
  //   else
  //     S.transcriptor  = null
  //     ### TAINT this call may crash the app when text marker has length zero ###
  //     try
  //       { clasz
  //         from
  //         to  }         = @position_and_clasz_from_mark marks[ 0 ]
  //     catch error
  //       @log 'Âµ44774', "failed when trying to get position, class from mark:", rpr error.message
  //       return null
  //     S.tsnr          = parseInt ( clasz.replace /^.*\btsr([0-9]+)\b.*$/, '$1' ), 10
  //     S.tsnr          = 0 unless CND.isa_number S.tsnr
  //     S.tsr_text      = @cm_text_from_mark marks[ 0 ]
  //     S.transcriptor  = S.transcriptors[ S.tsnr ]
  //     #.......................................................................................................
  //     unless S.transcriptor?
  //       S.tsnr          = 0
  //       S.transcriptor  = S.transcriptors[ S.tsnr ]
  //   #.........................................................................................................
  //   unless S.tsnr is 0
  //     @log 'Âµ53587', "TS##{rpr S.tsnr} (#{rpr S.transcriptor.display_name})"
  //     XE.emit PD.new_event '^transcribe', { text: S.tsr_text, from, to, }
  //   return null

  //===========================================================================================================
  // DIAGNOSTICS
  //-----------------------------------------------------------------------------------------------------------
  this.cm_mark_tsrs = function() {
    var clasz, from, fromto, i, j, len, len1, mark, marks, ref, to;
    ref = this.cm_get_selections_as_fromtos();
    /* Currently only used for diagnostics, will toggle CSS class `hilite` on all TSRs the selection is
    touching when `ctrl+m` is hit */
    /* TAINT code duplication */
    for (i = 0, len = ref.length; i < len; i++) {
      fromto = ref[i];
      if (CND.equals(fromto.from, fromto.to)) {
        marks = this.cm_get_marks_in_position(fromto.from);
      } else {
        marks = this.cm_get_marks_in_range(fromto);
      }
      if (marks.length === 0) {
        this.log('Âµ53688', `didn't find any marks at ${rpr(fromto)}`);
      } else {
        for (j = 0, len1 = marks.length; j < len1; j++) {
          mark = marks[j];
          this.log('Âµ53789', `found existing mark: ${rpr(this.position_and_clasz_from_mark(mark))}`);
          ({from, to, clasz} = this.position_and_clasz_from_mark(mark));
          mark.clear();
          clasz = (clasz.match(/\bhilite\b/)) != null ? clasz.replace(/\s*hilite\s*/g, ' ') : clasz + ' hilite';
          this.cm_set_mark({from, to}, clasz);
        }
      }
    }
    return null;
  };

}).call(this);

//# sourceMappingURL=ops-cm.js.map
