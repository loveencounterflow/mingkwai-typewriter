{
  "version": 3,
  "file": "db.js",
  "sourceRoot": "..",
  "sources": [
    "src/db.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = '明快打字机/DB'\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\ninfo                      = CND.get_logger 'info',      badge\nurge                      = CND.get_logger 'urge',      badge\nhelp                      = CND.get_logger 'help',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\nPATH                      = require 'path'\n# FS                        = require 'fs'\nPD                        = require 'pipedreams'\n{ $\n  $async\n  select }                = PD\n{ assign\n  jr }                    = CND\n#...........................................................................................................\njoin_path                 = ( P... ) -> PATH.resolve PATH.join P...\nboolean_as_int            = ( x ) -> if x then 1 else 0\n{ inspect, }              = require 'util'\nxrpr                      = ( x ) -> inspect x, { colors: yes, breakLength: Infinity, maxArrayLength: Infinity, depth: Infinity, }\nxrpr2                     = ( x ) -> inspect x, { colors: yes, breakLength: 80,       maxArrayLength: Infinity, depth: Infinity, }\n#...........................................................................................................\nICQL                      = require 'icql'\nINTERTYPE                 = require './types'\n\n\n#-----------------------------------------------------------------------------------------------------------\n@get_settings = ->\n  ### TAINT path within node_modules might differ ###\n  ### TAINT extensions should conceivably be configured in `*.icql` file or similar ###\n  # R.db_path   = join_path __dirname, '../../db/data.db'\n  R                 = {}\n  R.connector       = require 'better-sqlite3'\n  R.sqlitemk_path   = join_path __dirname, '../../../sqlite-for-mingkwai-ime'\n  R.db_path         = join_path __dirname, '../src/experiments/using-intercourse-with-sqlite.db'\n  R.icql_path       = join_path __dirname, '../src/experiments/using-intercourse-with-sqlite.icql'\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@new_db = ->\n  settings  = @get_settings()\n  db        = ICQL.bind settings\n  # db        = await ICQL.bind settings\n  db.$.load join_path settings.sqlitemk_path, 'extensions/csv.so'\n  db.$.load join_path settings.sqlitemk_path, 'extensions/spellfix.so'\n  db.$.load join_path settings.sqlitemk_path, 'extensions/regexp.so'\n  db.$.load join_path settings.sqlitemk_path, 'extensions/series.so'\n  db.$.load join_path settings.sqlitemk_path, 'extensions/nextchar.so'\n  # db.$.load join_path settings.sqlitemk_path, 'extensions/stmt.so'\n  db.$.pragma 'foreign_keys = on'\n  db.$.pragma 'synchronous = off' ### see https://sqlite.org/pragma.html#pragma_synchronous ###\n  # clear_count = db.$.clear()\n  # info \"deleted #{clear_count} objects\"\n  @create_db_functions db\n  # db.import_table_unames()\n  # db.import_table_uname_tokens()\n  # db.import_table_unicode_test()\n  # db.create_view_unicode_test_with_end_markers()\n  # db.fts5_create_and_populate_token_tables()\n  # db.spellfix_create_editcosts()\n  # db.spellfix_create_and_populate_token_tables()\n  # db.spellfix_populate_custom_codes()\n  return db\n\n#-----------------------------------------------------------------------------------------------------------\n@create_db_functions = ( db ) ->\n  # db.$.function 'add_spellfix_confusable', ( a, b ) ->\n  # db.$.function 'spellfix1_phonehash', ( x ) ->\n  #   debug '23363', x\n  #   return x.toUpperCase()\n  #.........................................................................................................\n  db.$.function 'echo', { deterministic: false, varargs: true }, ( P... ) ->\n    urge ( CND.grey 'DB' ), P...\n    return null\n  #.........................................................................................................\n  db.$.function 'e', { deterministic: false, varargs: false }, ( x ) ->\n    urge ( CND.grey 'DB' ), rpr x\n    return x\n  #.........................................................................................................\n  db.$.function 'plus', { deterministic: true, varargs: false }, ( a, b ) ->\n    debug '33444', a, b\n    return a + b\n  #.........................................................................................................\n  db.$.function 'contains_word', { deterministic: true, varargs: false }, ( text, probe ) ->\n    return if ( ( ' ' + text + ' ' ).indexOf ' ' + probe + ' ' ) > -1 then 1 else 0\n  #.........................................................................................................\n  db.$.function 'get_words', { deterministic: true, varargs: false }, ( text ) ->\n    JSON.stringify ( word for word in text.split /\\s+/ when word isnt '' )\n  #.........................................................................................................\n  db.$.function 'get_nth_word', { deterministic: true, varargs: false }, ( text, nr ) ->\n    ### NB SQLite has no string aggregation, no string splitting, and in general does not implement\n    table-returning user-defined functions (except in C, see the `prefixes` extension). Also, you can't\n    modify tables from within a UDF because the connection is of course busy executing the UDF.\n\n    As a consequence, it is well-nigh impossible to split strings to rows in a decent manner. You could\n    probably write a 12-liner with a recursive CTE each time you want to split a string. Unnecessary to\n    mention that SQLite does not support putting *that* thing into a UDF (because those can't return\n    anything except a single atomic value). It's a whack-a-mole game of missing pieces really.\n\n    The only ways out that I can see are either (1) preparing your data in the application code in such a\n    way that you never have to perform string splitting in the DB, or else (2) write functions like this\n    that accept a regular argument and a counter, query with a reasonable maximum counter value, and discard\n    all invalid rows:\n\n    ```sql\n    select\n        get_nth_word( 'helo world whassup', gs.value ) as word\n      from generate_series( 1, 10 ) as gs\n      where word is not null;\n    ```\n\n    Performance of this particular function could be improved by adding a small, short-lived cache, but I\n    guess that will be counterproductive as long as the texts to split are unlikely to contain more than a\n    very few words.\n\n    **Update** Turns out the `json1` extension can help out:\n\n    ```coffee\n    db.$.function 'get_words', { deterministic: true, varargs: false }, ( text ) ->\n      JSON.stringify ( word for word in text.split /\\s+/ when word isnt '' )\n    ```\n\n    ```sql\n    select\n        id    as nr,\n        value as word\n      from\n        json_each(\n          json(\n            get_words( 'helo world these are many words' ) ) );\n    ```\n\n\n    ###\n    parts = text.split /\\s+/\n    return parts[ nr - 1 ] ? null\n  return null\n\n\n\n\n"
  ]
}