// Generated by CoffeeScript 2.4.1
(function() {
  'use strict';
  var $, $async, CND, FS, KEYS, PATH, PD, T, XE, after, alert, assign, badge, debug, defer, help, info, inspect, isa, jr, rpr, type_of, types, urge, validate, warn, whisper, xrpr,
    indexOf = [].indexOf;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = '明快打字机/OPS-TRANSCRIPTION';

  debug = CND.get_logger('debug', badge);

  alert = CND.get_logger('alert', badge);

  whisper = CND.get_logger('whisper', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  info = CND.get_logger('info', badge);

  KEYS = require('../lib/keys');

  T = require('../lib/templates');

  PATH = require('path');

  FS = require('fs');

  //...........................................................................................................
  PD = require('pipedreams');

  ({jr} = CND);

  ({after} = CND.suspend);

  assign = Object.assign;

  defer = setImmediate;

  ({$, $async} = PD);

  // XE                        = null
  XE = require('../lib/xemitter');

  ({inspect} = require('util'));

  xrpr = function(x) {
    return inspect(x, {
      colors: true,
      breakLength: 2e308,
      maxArrayLength: 2e308,
      depth: 2e308
    });
  };

  types = require('./types');

  ({isa, validate, type_of} = types);

  //===========================================================================================================
  // INPUT TRANSLATION
  //-----------------------------------------------------------------------------------------------------------
  this.load_transcriptors = function() {
    var arity, directory_path, dt, filename, i, len, on_transcribe_types, ops, ref, ref1, relative_path, t0, t1, ts, tsnr, tsnr_by_sigils, type;
    PATH = require('path');
    FS = require('fs');
    tsnr = 0;
    ops = {};
    directory_path = PATH.resolve(PATH.join(__dirname, './transcriptors'));
    on_transcribe_types = ['function', 'asyncfunction'];
    S.transcriptors = [];
    tsnr_by_sigils = {};
    //.........................................................................................................
    /* insert TS0; consider to do this within the loop to avoid code duplication */
    ts = {};
    ts.standard_name = "(no transcriptor)";
    ts.display_name = ts.standard_name;
    ts.tsnr = 0;
    ts.sigil = 'ts0';
    ts.path = null;
    ts.module = null;
    S.transcriptors.push(ts);
    ref = FS.readdirSync(directory_path);
    //.........................................................................................................
    for (i = 0, len = ref.length; i < len; i++) {
      filename = ref[i];
      if (!filename.endsWith('.ts.js')) {
        continue;
      }
      t0 = Date.now();
      //.......................................................................................................
      tsnr += +1;
      ts = {};
      ts.tsnr = tsnr;
      ts.path = PATH.join(directory_path, filename);
      ts.standard_name = filename;
      ts.standard_name = ts.standard_name.replace(/\.ts\.js$/g, '');
      ts.standard_name = ts.standard_name.replace(/-/g, ' ');
      ts.display_name = ts.standard_name;
      ts.sigil = `ts${ts.tsnr}`;
      //.......................................................................................................
      relative_path = PATH.relative(process.cwd(), ts.path);
      this.log(`µ44755 loading transcription ${relative_path}`);
      ts.module = require(ts.path);
      /* NOTE not used ATTB and probably not needed; transcriptors should execute any initialization code
      on module `require`d and/or immediately prior to first use. */
      // #.......................................................................................................
      // if ts.module.init?
      //   unless ( type = CND.type_of ts.module.init ) in on_transcribe_types
      //     throw new Error "µ27622 expected a function for #{relative_path}.init, got a #{type}"
      //   await ts.module.init()
      //.......................................................................................................
      if (ts.module.display_name != null) {
        if ((type = CND.type_of(ts.module.display_name)) !== 'text') {
          throw new Error(`µ27622 expected a text for ${relative_path}.display_name, got a ${type}`);
        }
        ts.display_name = ts.module.display_name;
      }
      //.......................................................................................................
      if (ts.module.sigil != null) {
        if ((type = CND.type_of(ts.module.sigil)) !== 'text') {
          throw new Error(`µ27622 expected a text for ${relative_path}.sigil, got a ${type}`);
        }
        ts.sigil = ts.module.sigil;
      }
      //.......................................................................................................
      if (ref1 = (type = CND.type_of(ts.module.on_transcribe)), indexOf.call(on_transcribe_types, ref1) < 0) {
        throw new Error(`µ27622 expected a function for ${relative_path}.on_transcribe, got a ${type}`);
      }
      if ((arity = ts.module.on_transcribe.length) !== 1) {
        throw new Error(`µ27622 arity ${arity} for ${relative_path}.on_transcribe not implemented`);
      }
      //.......................................................................................................
      S.tsnr_by_sigils[ts.sigil] = ts.tsnr;
      S.transcriptors.push(ts);
      t1 = Date.now();
      dt = t1 - t0;
      this.log(`µ44755 ${filename} loaded as ${rpr(ts.display_name)} (TSNR ${ts.tsnr}; took ${dt} ms)`);
    }
    //.........................................................................................................
    // info 'µ33736', S.transcriptors
    return null;
  };

  //===========================================================================================================
  // SET TSRs, TRANSCRIPTORS
  //-----------------------------------------------------------------------------------------------------------
  this.format_existing_tsms = function(d) {
    var cursor, finds, from, fromto, i, len, pattern, ref, ref1, ref2, ref3, sigil, text, to, tsm_prefix, tsm_suffix, tsnr;
    /* Listens to `^open-document`, iterates over document and calls `format_as_tsm_at_position()` for
    each transcription mark found. */
    /* TAINT precompute, store in S: */
    /* TAINT code duplication */
    //.........................................................................................................
    tsm_prefix = (ref = (ref1 = S.transcriptor_region_markers) != null ? ref1.prefix : void 0) != null ? ref : '\u{f11c}';
    tsm_suffix = (ref2 = (ref3 = S.transcriptor_region_markers) != null ? ref3.suffix : void 0) != null ? ref2 : '\u{f005}';
    pattern = RegExp(`${tsm_prefix}(?<sigil>[^${tsm_suffix}]+)${tsm_suffix}`);
    finds = [];
    cursor = S.codemirror.editor.getSearchCursor(pattern);
    // @log 'µ11121', rpr ( key for key of cursor )
    //.........................................................................................................
    while (cursor.findNext()) {
      from = cursor.from();
      to = cursor.to();
      fromto = {from, to};
      text = this.cm_get_text(fromto);
      ({sigil} = (text.match(pattern)).groups);
      tsnr = S.tsnr_by_sigils[sigil];
      /* TAINT must fall back to 'unknown TS' or similar when sigil not found */
      finds.push({fromto, tsnr, sigil});
    }
//.........................................................................................................
    for (i = 0, len = finds.length; i < len; i++) {
      ({fromto, tsnr, sigil} = finds[i]);
      this.log("µ46674", `found TSM at ${rpr(fromto)}: ${rpr(text)} (TS #${tsnr})`);
      this.format_as_tsm_at_position(fromto, tsnr, sigil);
    }
    //.........................................................................................................
    return null;
  };

  // for line_idx in [ S.codemirror.editor.firstLine() .. S.codemirror.editor.lastLine() ]
  //   text =

  //-----------------------------------------------------------------------------------------------------------
  this.format_as_tsm_at_position = function(fromto, tsnr, sigil) {
    var clasz, settings;
    /* Called by `format_existing_tsms()`, `on_replace_text()` to insert an atomic CM textmarker at the
    position indicated. */
    /* TAINT unify with `toggle_tsm_at_position` */
    validate.range(fromto);
    validate.tsnr(tsnr);
    clasz = `tsr tsr${tsnr}`;
    settings = {
      attributes: {tsnr},
      replacedWith: (jQuery(`<span class=${jr(clasz)}>${sigil}</span>`))[0],
      atomic: true,
      inclusiveLeft: false,
      inclusiveRight: false
    };
    /* TAINT use own API */
    S.codemirror.editor.markText(fromto.from, fromto.to, settings);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.toggle_tsm_at_position = function(position, tsnr, sigil) {
    var clasz, old_textmarker, old_tsnr, ref, ref1, ref2, ref3, ref4, ref5, ref6, rposition, settings, tsm, tsm_prefix, tsm_suffix;
    /* Called by `insert_tsm()`. */
    /* TSM: TranScription Marker. TSR (TranScription Region) extends from marker up to cursor. */
    /* TAINT unify with `format_as_tsm_at_position` */
    /* TAINT precompute, store in S.transcriptors: */
    validate.position(position);
    validate.tsnr(tsnr);
    old_textmarker = (ref = (S.codemirror.editor.findMarksAt(position))[0]) != null ? ref : null;
    old_tsnr = (ref1 = old_textmarker != null ? (ref2 = old_textmarker.attributes) != null ? ref2.tsnr : void 0 : void 0) != null ? ref1 : null;
    //.........................................................................................................
    if ((tsnr !== 0) && ((old_textmarker == null) || (old_tsnr !== tsnr))) {
      tsm_prefix = (ref3 = (ref4 = S.transcriptor_region_markers) != null ? ref4.prefix : void 0) != null ? ref3 : '\u{f11c}';
      tsm_suffix = (ref5 = (ref6 = S.transcriptor_region_markers) != null ? ref6.suffix : void 0) != null ? ref5 : '\u{f005}';
      tsm = `${tsm_prefix}${sigil}${tsm_suffix}`;
      clasz = `tsr tsr${tsnr}`;
      rposition = {
        line: position.line,
        ch: position.ch + tsm.length
      };
      settings = {
        attributes: {tsnr},
        replacedWith: (jQuery(`<span class=${jr(clasz)}>${sigil}</span>`))[0],
        atomic: true,
        inclusiveLeft: false,
        inclusiveRight: false
      };
      /* TAINT use own API */
      S.codemirror.editor.replaceRange(tsm, position);
      S.codemirror.editor.markText(position, rposition, settings);
    }
    if (old_textmarker != null) {
      //.........................................................................................................
      this.cm_remove_textmarker(old_textmarker);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.insert_tsm = function(tsnr) {
    /* Bound to `ctrl+0` ... `ctrl+4` */
    var position, ts;
    /* Called upon keyboard shortcut, menu item selection. */
    validate.tsnr(tsnr);
    ts = S.transcriptors[tsnr];
    if (ts == null) {
      ts = S.transcriptors[0];
    }
    position = this.cm_get_position();
    this.toggle_tsm_at_position(position, tsnr, ts.sigil);
    // @emit_transcribe_event()
    return null;
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @insert_bookmark = ( position = null ) ->
  //   position ?= @cm_get_position()
  //   validate.position position
  //   @log 'µ44644', 'position', position
  //   sigil = 'SIGIL'
  //   settings =
  //     widget:             ( jQuery "<span class=tsm-bookmark>#{sigil}</span>" )[ 0 ]
  //     insertLeft:         false
  //     shared:             false
  //     handleMouseEvents:  false
  //   return S.codemirror.editor.setBookmark position, settings

  //===========================================================================================================
  // MOVES
  //-----------------------------------------------------------------------------------------------------------
  this.cm_jump_to_tsr_or_bracket = function() {
    return this.log('µ44455', "cm_jump_to_tsr_or_bracket not implemented");
  };

  this.cm_mark_tsr_or_bracket = function() {
    return this.log('µ44455', "cm_mark_tsr_or_bracket not implemented");
  };

  //===========================================================================================================
  // INPUT TRANSLATION
  //-----------------------------------------------------------------------------------------------------------
  this.emit_transcribe_event = function() {
    /* Called on cursor move in CM and by `insert_tsm()`, `emit_transcribe_event()` parses the current line,
    looks for the relevant TSM (TranScription Mark), and formulates a transcription event based on the text
    found between the TSM and the cursor position. That event is then processed by
    `dispatch_transcribe_event()` (and possibly other listeners). */
    /* TAINT consider to always use either TSNR or TS sigil in text marker, displayed text, and only use
    that piece of data to identify transcriptors in events */
    /* TAINT precompute, store in S: */
    /* TAINT code duplication, see `ops-cm/format_tsr_marks()` */
    var all, full_text, mark, match, origin, otext, pattern, position, ref, ref1, ref2, ref3, sigil, target, tsm, tsm_prefix, tsm_suffix, tsnr;
    position = this.cm_get_cursor();
    // @log 'µ36373', 'position', position
    full_text = (this.cm_text_from_line_idx(position.line)).slice(0, position.ch);
    if (full_text.length === 0/* TAINT consider whether transcriptions with empty text might be useful */) {
      return null;
    }
    tsm_prefix = (ref = (ref1 = S.transcriptor_region_markers) != null ? ref1.prefix : void 0) != null ? ref : '\u{f11c}';
    tsm_suffix = (ref2 = (ref3 = S.transcriptor_region_markers) != null ? ref3.suffix : void 0) != null ? ref2 : '\u{f005}';
    pattern = RegExp(`^.*(?<all>(?<mark>${tsm_prefix}(?<sigil>[^${tsm_suffix}]+)${tsm_suffix}(?<otext>.*?)))$`);
    if ((match = full_text.match(pattern)) == null) {
      return;
    }
    ({mark, sigil, otext, all} = match.groups);
    tsnr = S.tsnr_by_sigils[sigil];
    if (tsnr == null) {
      tsnr = 0;
    }
    if (tsnr === 0) {
      //.........................................................................................................
      return null;
    }
    //.........................................................................................................
    /* where to put ntext: */
    target = {
      line: position.line,
      ch: position.ch - all.length
    };
    //.........................................................................................................
    origin = {
      from: {
        line: position.line,
        ch: position.ch - otext.length
      },
      to: {
        line: position.line,
        ch: position.ch
      }
    };
    //.........................................................................................................
    tsm = {
      from: {
        line: target.line,
        ch: target.ch
      },
      to: {
        line: target.line,
        ch: target.ch + mark.length
      }
    };
    //.........................................................................................................
    XE.emit(PD.new_event('^transcribe', {otext, tsnr, sigil, target, tsm, origin}));
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.dispatch_transcribe_event = function(d) {
    /* Called on `^transcribe` events. If indicated transcription module exists, calls its `on_transcribe()`
    method (which in turn may cause events like `^replace-text`, `^candidates` to be emitted). */
    var ref, ref1, transcriptor, tsnr;
    transcriptor = S.transcriptors[d.value.tsnr];
    //.......................................................................................................
    if ((transcriptor != null ? (ref = transcriptor.module) != null ? ref.on_transcribe : void 0 : void 0) == null) {
      tsnr = 0;
      transcriptor = S.transcriptors[tsnr];
    }
    //.......................................................................................................
    if ((transcriptor != null ? (ref1 = transcriptor.module) != null ? ref1.on_transcribe : void 0 : void 0) != null) {
      // @log 'µ33111', "calling #{transcriptor.display_name}", rpr d
      transcriptor.module.on_transcribe(d);
    } else {
      //.......................................................................................................
      this.log('µ33111', 'no transcriptor');
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  /* When `is_frozen()` is `true`, `^transcribe` events as result of cursor activities will not be sent; this
  is to prevent text replacements from causing `^trancribe` events themselves. This simple method *should* be
  OK as JS is single-threaded and interface updates are not possible until `on_replace_text()` (or any
  function) has terminated. */
  this.freeze = function() {
    return S.is_frozen = true;
  };

  this.is_frozen = function() {
    return S.is_frozen;
  };

  this.thaw = function() {
    return S.is_frozen = false;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.on_replace_text = function(d) {
    var target, v;
    /* Called on `^replace-text` events (issued by transcriptors). */
    // @log 'µ53486', 'on_replace_text', ( rpr d ), ( isa.replace_text_event d.value )
    validate.replace_text_event(v = d.value);
    this.freeze();
    /* TAINT use own API */
    if (v.match != null) {
      target = {
        line: v.origin.from.line,
        ch: v.origin.from.ch + v.match.length
      };
      S.codemirror.editor.replaceRange('', v.origin.from, target);
    } else {
      S.codemirror.editor.replaceRange('', v.origin.from, v.origin.to);
    }
    // @toggle_tsm_at_position v.origin, v.tsnr, v.sigil               ### insert new TSM (where called for) ###
    //.........................................................................................................
    /* delete original text */    S.codemirror.editor.replaceRange(v.ntext, v.target);
// S.codemirror.editor.replaceRange '', v.tsm.from, v.tsm.to       ### delete TSM ###
// S.codemirror.editor.replaceRange v.ntext, v.target              ### insert new tsm ###
//.........................................................................................................
/* insert new text */    if (v.match != null) {
      this.emit_transcribe_event();
    }
    //.........................................................................................................
    this.thaw();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.display_candidates = function(d) {
    var entry, glyphboxes, i, idx, len, nv, ref, ref1, rows, v;
    v = d.value;
    (jQuery('#candidates-flexgrid div')).remove();
    //.........................................................................................................
    if (v.candidates.length === 0) {
      if (S.focus_is_candidates) {
        this.focusframe_to_editor;
      }
      // @index_candidates()
      return null;
    }
    if ((!S.focus_is_candidates) && ((ref = v.focus_candidates) != null ? ref : true)) {
      //.........................................................................................................
      this.focusframe_to_candidates();
    }
    //.........................................................................................................
    rows = [];
    ref1 = v.candidates;
    for (idx = i = 0, len = ref1.length; i < len; idx = ++i) {
      entry = ref1[idx];
      rows.push(T.get_flexgrid_html(idx + 1, entry.candidate));
    }
    (jQuery('#candidates-flexgrid')).append(rows.join('\n'));
    //.........................................................................................................
    /* TAINT code duplication */
    glyphboxes = jQuery('#candidates-flexgrid div.glyph');
    nv = assign({}, v);
    delete nv.candidates;
    glyphboxes.on('click', (e) => {
      var lnr, match, me, ref2, ref3;
      me = jQuery(e.target);
      /* TAINT code duplication */
      /* TAINT use API to move selection */
      glyphboxes.removeClass('cdtsel');
      me.addClass('cdtsel');
      //.......................................................................................................
      lnr = parseInt(me.attr('lnr'), 10);
      // lcol  = me.attr 'lcol'
      // @log "µ33983 clicked on #{me.text()} #{jr lnr} / #{jr lcol}"
      match = (ref2 = (ref3 = v.candidates[lnr - 1]) != null ? ref3.reading : void 0) != null ? ref2 : null;
      return XE.emit(PD.new_event('^replace-text', assign(nv, {
        ntext: me.text(),
        match
      })));
    });
    //.........................................................................................................
    this.index_candidates();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.select_candidate_or_insert_space = function() {
    var cdtsel;
    if (!S.focus_is_candidates) {
      /* TAINT this implementation precludes any other functionality that the space bar might be associated
      with in CodeMirror */
      /* TAINT code duplication */
      return S.codemirror.editor.replaceSelection(' ');
    }
    cdtsel = jQuery('.cdtsel');
    /* TAINT honour multiple selection */
    if (cdtsel.length > 0) {
      cdtsel.click();
    } else {
      S.codemirror.editor.replaceSelection(' ');
    }
    this.focusframe_to_editor();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.index_candidates = function() {
    /* Add or update each candidate `<div class=glyph> with attributes indicating its left- and right-based
    column and row numbers, starting from 1. Elements that match `jQuery '[lrow=1]'` are in the first row from
    the top, while those that match `jQuery '[rrow=1]'` are in the last row from top (first row from the
    bottom). Likewise, `lcol=1`, `rcol=1` match the leftmost and rightmost elements. These indexes have to be
    re-calculated after each container resize event, but simplify the code needed to select single and groups
    of elements. The beauty of the scheme is that we can select e.g. all leftmost elements or all elements
    in the first row (should the need ever arise). */
    /* TAINT code duplication */
    var candidate_count, col_count, col_idx, glyphbox, glyphboxes, i, idx, j, k, l, lcol, len, len1, len2, lnr, lrow, nxt_top, prv_top, ref, rnr, row, row_count, row_idx, rows, sub_glyphbox;
    glyphboxes = jQuery('#candidates-flexgrid div.glyph');
    lcol = 0;
    lrow = 0;
    prv_top = null;
    candidate_count = glyphboxes.length;
    lnr = 0;
    rnr = candidate_count + 1;
    rows = [];
    row = null;
    //.........................................................................................................
    this.log(`index_candidates() (${candidate_count})`);
//.........................................................................................................
    for (idx = i = 0, ref = candidate_count; (0 <= ref ? i < ref : i > ref); idx = 0 <= ref ? ++i : --i) {
      glyphbox = glyphboxes.eq(idx);
      //.......................................................................................................
      if ((nxt_top = glyphbox.offset().top) !== prv_top) {
        if (row != null) {
          rows.push(row);
          col_count = row.length;
          for (col_idx = j = 0, len = row.length; j < len; col_idx = ++j) {
            sub_glyphbox = row[col_idx];
            sub_glyphbox.attr('rcol', col_count - col_idx);
          }
        }
        //.....................................................................................................
        row = [];
        prv_top = nxt_top;
        lcol = 0;
        lrow += +1;
      }
      //.......................................................................................................
      row.push(glyphbox);
      lnr += +1;
      rnr += -1;
      lcol += +1;
      //.......................................................................................................
      glyphbox.attr('lnr', lnr);
      glyphbox.attr('rnr', rnr);
      glyphbox.attr('lcol', lcol);
      glyphbox.attr('lrow', lrow);
    }
    if (row != null) {
      //.........................................................................................................
      rows.push(row);
    }
    row_count = rows.length;
    for (row_idx = k = 0, len1 = rows.length; k < len1; row_idx = ++k) {
      row = rows[row_idx];
      for (l = 0, len2 = row.length; l < len2; l++) {
        glyphbox = row[l];
        glyphbox.attr('rrow', row_count - row_idx);
      }
    }
    //.........................................................................................................
    rows.length = 0/* not strictly needed, just to make de-allocation explicit */
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._select_delta_candidate = function(deltas) {
    var R, delta_key, delta_value, glyphboxes, nxt_cdtsel, nxt_selector, nxt_value, prv_cdtsel, prv_value, type;
    /* Select next candidate(s) based on `deltas`, which should be an object with one or more of the
    following members:

    * **`lnr`**:     left-anchored  candidate         number
    * **`lcol`**:    left-anchored  column            number
    * **`lrow`**:    left-anchored  row (i.e. line)   number
    * **`rnr`**:     right-anchored candidate         number
    * **`rcol`**:    right-anchored column            number
    * **`rrow`**:    right-anchored row (i.e. line)   number

    Left-anchored values count from the usual (i.e. top or left) end of that dimension, richt-anchored ones
    from the opposite sides; for example, `lcol: 1` selects the first (leftmost), `rcol: 1` the last
    (rightmost) entry in each row; `lrow: 1` the first row, `rrow: 1` the last one; in a line with, say, five
    candidates, `lrow: 4` is equivalent to `rrow: 2`, and `lrow: 5` is the same as `rrow: 1`.

    Each entry may be either a positive or negative integer, or zero, or 'first', or 'last'. A non-zero number
    indicates the number of steps to go in the respective dimension while zero indicates 'keep this value'.
    For example, to move right irregardless of line breaks, use `{ lnr: +1, }`. To move to the first entry on
    the next line, use `{ lcol: 'first', lrow: +1, }`. To go to the last entry of the current row, use `{
    lrow: 0, lcol: 'last', }` or `{ lrow: 0, rcol: 'first', }`. The selected candidates are the intersection
    of all sub-selectors.

    This method will have no effect unless there is one or more selected entries to start with.  */
    //.........................................................................................................
    R = 0;
    prv_cdtsel = jQuery('.cdtsel');
    //.........................................................................................................
    if (prv_cdtsel.length === 0) {
      this.log("_select_delta_candidate: no candidate selected");
      return R;
    }
    //.........................................................................................................
    /* TAINT code duplication */
    glyphboxes = jQuery('#candidates-flexgrid div.glyph');
    nxt_selector = [];
//.........................................................................................................
    for (delta_key in deltas) {
      delta_value = deltas[delta_key];
      switch (type = CND.type_of(delta_value)) {
        case 'text':
          switch (delta_value) {
            case 'first':
              nxt_selector.push(`[${delta_key}=1]`);
              break;
            case 'last':
              delta_key = delta_key.replace(/^[rl]/, function($0) {
                if ($0 === 'l') {
                  return 'r';
                } else {
                  return 'l';
                }
              });
              nxt_selector.push(`[${delta_key}=1]`);
              break;
            default:
              throw new Error(`µ37634 unknown move command ${rpr(delta_value)}`);
          }
          break;
        case 'number':
          prv_value = parseInt(prv_cdtsel.attr(delta_key), 10);
          nxt_value = prv_value + delta_value;
          nxt_selector.push(`[${delta_key}=${nxt_value}]`);
          break;
        default:
          throw new Error(`µ37633 expected a text or a number, got a ${type}`);
      }
    }
    nxt_selector = nxt_selector.join('');
    this.log(`_select_delta_candidate ${jr(deltas)} ${jr(nxt_selector)}`);
    if ((R = (nxt_cdtsel = glyphboxes.filter(nxt_selector)).length) === 0) {
      return R;
    }
    prv_cdtsel.removeClass('cdtsel');
    nxt_cdtsel.addClass('cdtsel');
    nxt_cdtsel[0].scrollIntoViewIfNeeded();
    return R;
  };

}).call(this);

//# sourceMappingURL=ops-transcription.js.map
