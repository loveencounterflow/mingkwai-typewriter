// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var $, $async, CND, FS, KEYS, PATH, PD, T, XE, after, alert, assign, badge, debug, defer, help, info, inspect, jr, rpr, urge, warn, whisper, xrpr,
    indexOf = [].indexOf;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = '明快打字机/OPS-TRANSCRIPTION';

  debug = CND.get_logger('debug', badge);

  alert = CND.get_logger('alert', badge);

  whisper = CND.get_logger('whisper', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  info = CND.get_logger('info', badge);

  KEYS = require('../lib/keys');

  T = require('../lib/templates');

  PATH = require('path');

  FS = require('fs');

  //...........................................................................................................
  PD = require('pipedreams');

  ({jr} = CND);

  ({after} = CND.suspend);

  assign = Object.assign;

  defer = setImmediate;

  ({$, $async} = PD);

  // XE                        = null
  XE = require('../lib/xemitter');

  ({inspect} = require('util'));

  xrpr = function(x) {
    return inspect(x, {
      colors: true,
      breakLength: 2e308,
      maxArrayLength: 2e308,
      depth: 2e308
    });
  };

  //===========================================================================================================
  // INPUT TRANSLATION
  //-----------------------------------------------------------------------------------------------------------
  this.load_transcriptors = async function() {
    var arity, directory_path, filename, i, len, on_transcribe_types, ops, ref, ref1, ref2, relative_path, t, type;
    PATH = require('path');
    FS = require('fs');
    ops = {};
    directory_path = PATH.resolve(PATH.join(__dirname, './transcriptors'));
    on_transcribe_types = ['function', 'asyncfunction'];
    S.transcriptors = [];
    //.........................................................................................................
    t = {};
    t.display_name = "(no transcriptor)";
    t.path = null;
    t.module = null;
    S.transcriptors.push(t);
    ref = FS.readdirSync(directory_path);
    //.........................................................................................................
    for (i = 0, len = ref.length; i < len; i++) {
      filename = ref[i];
      if (!filename.endsWith('.ts.js')) {
        continue;
      }
      //.......................................................................................................
      t = {};
      t.path = PATH.join(directory_path, filename);
      t.display_name = filename;
      t.display_name = t.display_name.replace(/\.ts\.js$/g, '');
      t.display_name = t.display_name.replace(/-/g, ' ');
      //.......................................................................................................
      relative_path = PATH.relative(process.cwd(), t.path);
      this.log(`µ44755 loading transcription ${relative_path}`);
      t.module = require(t.path);
      //.......................................................................................................
      if (t.module.init != null) {
        if (ref1 = (type = CND.type_of(t.module.init)), indexOf.call(on_transcribe_types, ref1) < 0) {
          throw new Error(`µ27622 expected a function for ${relative_path}.init, got a ${type}`);
        }
        await t.module.init();
      }
      //.......................................................................................................
      if (t.module.display_name != null) {
        if ((type = CND.type_of(t.module.display_name)) !== 'text') {
          throw new Error(`µ27622 expected a text for ${relative_path}.display_name, got a ${type}`);
        }
        t.display_name = t.module.display_name;
      }
      //.......................................................................................................
      if (ref2 = (type = CND.type_of(t.module.on_transcribe)), indexOf.call(on_transcribe_types, ref2) < 0) {
        throw new Error(`µ27622 expected a function for ${relative_path}.on_transcribe, got a ${type}`);
      }
      if ((arity = t.module.on_transcribe.length) !== 1) {
        throw new Error(`µ27622 arity ${arity} for ${relative_path}.on_transcribe not implemented`);
      }
      //.......................................................................................................
      S.transcriptors.push(t);
      t.tsnr = S.transcriptors.length;
      this.log(`µ44755 ${filename} loaded as ${rpr(t.display_name)} (TRS# ${t.tsnr})`);
    }
    //.........................................................................................................
    // info 'µ33736', S.transcriptors
    return null;
  };

  //===========================================================================================================
  // SET TSRs, TRANSCRIPTORS
  //-----------------------------------------------------------------------------------------------------------
  this.format_existing_tsr_marks = function(d) {
    /* TAINT precompute, store in S: */
    /* TAINT code duplication */
    var cursor, finds, from, fromto, i, len, pattern, ref, ref1, ref2, ref3, text, to, tsnr, tsrm_prefix, tsrm_suffix;
    tsrm_prefix = (ref = (ref1 = S.transcriptor_region_markers) != null ? ref1.prefix : void 0) != null ? ref : '\u{f11c}';
    tsrm_suffix = (ref2 = (ref3 = S.transcriptor_region_markers) != null ? ref3.suffix : void 0) != null ? ref2 : '\u{f005}';
    pattern = RegExp(`${tsrm_prefix}(?<tsnr>[0-9]+)${tsrm_suffix}`);
    finds = [];
    cursor = S.codemirror.editor.getSearchCursor(pattern);
    // @log 'µ11121', rpr ( key for key of cursor )
    //.........................................................................................................
    while (cursor.findNext()) {
      from = cursor.from();
      to = cursor.to();
      fromto = {from, to};
      text = this.cm_get_text(fromto);
      ({tsnr} = (text.match(pattern)).groups);
      tsnr = parseInt(tsnr, 10);
      finds.push({fromto, tsnr});
    }
//.........................................................................................................
    for (i = 0, len = finds.length; i < len; i++) {
      ({fromto, tsnr} = finds[i]);
      this.log("µ46674", `found TSR mark at ${rpr(fromto)}: ${rpr(text)} (TS #${tsnr})`);
      this.cm_format_as_tsr_mark(fromto, tsnr);
    }
    //.........................................................................................................
    return null;
  };

  // for line_idx in [ S.codemirror.editor.firstLine() .. S.codemirror.editor.lastLine() ]
  //   text =

  //-----------------------------------------------------------------------------------------------------------
  this.cm_format_as_tsr_mark = function(fromto, tsnr) {
    /* TAINT use own API */
    var settings;
    settings = {
      className: `tsr tsr${tsnr}`,
      atomic: true,
      inclusiveLeft: false,
      inclusiveRight: false
    };
    S.codemirror.editor.markText(fromto.from, fromto.to, settings);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.cm_insert_tsr_mark = function(fromto, tsnr) {
    /* TAINT use configured TS sigil instead of tsnr */
    /* TSRM: TranScription Region Marker. TSR extends from marker up to cursor. */
    /* TAINT precompute, store in S.transcriptors: */
    var clasz, fromto_right, ref, ref1, ref2, ref3, settings, tsrm, tsrm_prefix, tsrm_suffix;
    tsrm_prefix = (ref = (ref1 = S.transcriptor_region_markers) != null ? ref1.prefix : void 0) != null ? ref : '\u{f11c}';
    tsrm_suffix = (ref2 = (ref3 = S.transcriptor_region_markers) != null ? ref3.suffix : void 0) != null ? ref2 : '\u{f005}';
    tsrm = `${tsrm_prefix}${tsnr}${tsrm_suffix}`;
    clasz = `tsr tsr${tsnr}`;
    fromto_right = {
      line: fromto.from.line,
      ch: fromto.from.ch + tsrm.length
    };
    settings = {
      className: clasz,
      atomic: true,
      inclusiveLeft: false,
      inclusiveRight: false
    };
    /* TAINT use own API */
    S.codemirror.editor.replaceRange(tsrm, fromto.from);
    S.codemirror.editor.markText(fromto.from, fromto_right, settings);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.cm_set_tsrs = function(tsnr) {
    /* Bound to `ctrl+0` ... `ctrl+4` */
    var action, clasz, delta, fromto, i, len, ref;
    action = tsnr === 0 ? 'clear' : 'set';
    if (action === 'clear') {
      this.log('µ48733-1', "clear TSR not implemented");
      return null;
    }
    delta = action === 'clear' ? -1 : +1;
    clasz = `tsr tsr${tsnr}`;
    ref = this.cm_get_selections_as_fromtos();
    for (i = 0, len = ref.length; i < len; i++) {
      fromto = ref[i];
      if (!this.cm_range_is_point(fromto)) {
        this.log('µ48733-2', "non-point ranges not implemented");
        return null;
      }
      this.log('µ48733-4', rpr(fromto));
      /* TAINT allow to configure appearance of TSR mark */
      // tsrm = "[#{S.transcriptors[ tsnr ].display_name}:"
      this.cm_insert_tsr_mark(fromto, tsnr);
    }
    this.emit_transcribe_event();
    return null;
  };

  //===========================================================================================================
  // MOVES
  //-----------------------------------------------------------------------------------------------------------
  this.cm_jump_to_tsr_or_bracket = function() {
    return this.log('µ44455', "cm_jump_to_tsr_or_bracket not implemented");
  };

  this.cm_mark_tsr_or_bracket = function() {
    return this.log('µ44455', "cm_mark_tsr_or_bracket not implemented");
  };

  //===========================================================================================================
  // INPUT TRANSLATION
  //-----------------------------------------------------------------------------------------------------------
  this.emit_transcribe_event = function() {
    /* TAINT precompute, store in S: */
    /* TAINT code duplication, see `ops-cm/format_tsr_marks()` */
    var all, full_text, match, otext, pattern, position, ref, ref1, ref2, ref3, tsnr, tsrm_prefix, tsrm_suffix, value;
    position = this.cm_get_cursor();
    full_text = (this.cm_text_from_line_idx(position.line)).slice(0, position.ch);
    if (full_text.length === 0/* TAINT consider whether transcriptions with empty text might be useful */) {
      return null;
    }
    tsrm_prefix = (ref = (ref1 = S.transcriptor_region_markers) != null ? ref1.prefix : void 0) != null ? ref : '\u{f11c}';
    tsrm_suffix = (ref2 = (ref3 = S.transcriptor_region_markers) != null ? ref3.suffix : void 0) != null ? ref2 : '\u{f005}';
    pattern = RegExp(`^.*(?<all>${tsrm_prefix}(?<tsnr>[0-9]+)${tsrm_suffix}(?<otext>.*?))$`);
    if ((match = full_text.match(pattern)) == null) {
      return;
    }
    ({tsnr, otext, all} = match.groups);
    tsnr = parseInt(tsnr, 10);
    if (tsnr === 0) {
      return null;
    }
    value = {
      otext: otext,
      tsnr: tsnr,
      target: {
        line: position.line,
        ch: position.ch - all.length
      },
      origin: {
        from: {
          line: position.line,
          ch: position.ch - otext.length
        },
        to: position
      }
    };
    XE.emit(PD.new_event('^transcribe', value));
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.dispatch_transcribe_event = function(d) {
    var ref, ref1, transcriptor, tsnr;
    transcriptor = S.transcriptors[d.value.tsnr];
    //.......................................................................................................
    if ((transcriptor != null ? (ref = transcriptor.module) != null ? ref.on_transcribe : void 0 : void 0) == null) {
      tsnr = 0;
      transcriptor = S.transcriptors[tsnr];
    }
    //.......................................................................................................
    if ((transcriptor != null ? (ref1 = transcriptor.module) != null ? ref1.on_transcribe : void 0 : void 0) != null) {
      this.log('µ33111', `calling ${transcriptor.display_name}`, rpr(d));
      transcriptor.module.on_transcribe(d);
    } else {
      //.......................................................................................................
      this.log('µ33111', 'no transcriptor');
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.freeze = function() {
    return S.is_frozen = true;
  };

  this.is_frozen = function() {
    return S.is_frozen;
  };

  this.thaw = function() {
    return S.is_frozen = false;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.on_replace_text = function(d) {
    var v;
    this.log('µ53486', 'on_replace_text', rpr(d));
    v = d.value;
    this.freeze();
    /* TAINT use own API */
    S.codemirror.editor.replaceRange('', v.origin.from, v.origin.to);
    S.codemirror.editor.replaceRange(v.ntext, v.target);
    this.thaw();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.display_candidates = function(d) {
    var glyph, glyphboxes, idx, rows, v;
    v = d.value;
    (jQuery('#candidates-flexgrid div')).remove();
    //.........................................................................................................
    if (v.candidates.length === 0) {
      if (S.focus_is_candidates) {
        this.focusframe_to_editor;
      }
      // @index_candidates()
      return null;
    }
    if (!S.focus_is_candidates) {
      //.........................................................................................................
      this.focusframe_to_candidates();
    }
    rows = ((function() {
      var i, len, ref, results;
      ref = v.candidates;
      results = [];
      for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
        glyph = ref[idx];
        results.push(T.get_flexgrid_html(idx + 1, glyph));
      }
      return results;
    })()).join('\n');
    (jQuery('#candidates-flexgrid')).append(rows);
    //.........................................................................................................
    /* TAINT code duplication */
    glyphboxes = jQuery('#candidates-flexgrid div.glyph');
    glyphboxes.on('click', (e) => {
      var me;
      me = jQuery(e.target);
      /* TAINT code duplication */
      /* TAINT use API to move selection */
      glyphboxes.removeClass('cdtsel');
      me.addClass('cdtsel');
      //.......................................................................................................
      // lnr   = me.attr 'lnr'
      // lcol  = me.attr 'lcol'
      // @log "µ33983 clicked on #{me.text()} #{jr lnr} / #{jr lcol}"
      d.value.ntext = me.text();
      return XE.emit(PD.new_event('^replace-text', d.value));
    });
    //.........................................................................................................
    this.index_candidates();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.select_candidate_or_insert_space = function() {
    /* TAINT this implementation precludes any other functionality that the space bar might be associated
    with in CodeMirror */
    var cdtsel;
    cdtsel = jQuery('.cdtsel');
    /* TAINT honour multiple selection */
    if (cdtsel.length > 0) {
      cdtsel.click();
    } else {
      S.codemirror.editor.replaceSelection(' ');
    }
    this.focusframe_to_editor();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.index_candidates = function() {
    /* Add or update each candidate `<div class=glyph> with attributes indicating its left- and right-based
    column and row numbers, starting from 1. Elements that match `jQuery '[lrow=1]'` are in the first row from
    the top, while those that match `jQuery '[rrow=1]'` are in the last row from top (first row from the
    bottom). Likewise, `lcol=1`, `rcol=1` match the leftmost and rightmost elements. These indexes have to be
    re-calculated after each container resize event, but simplify the code needed to select single and groups
    of elements. The beauty of the scheme is that we can select e.g. all leftmost elements or all elements
    in the first row (should the need ever arise). */
    /* TAINT code duplication */
    var candidate_count, col_count, col_idx, glyphbox, glyphboxes, i, idx, j, k, l, lcol, len, len1, len2, lnr, lrow, nxt_top, prv_top, ref, rnr, row, row_count, row_idx, rows, sub_glyphbox;
    glyphboxes = jQuery('#candidates-flexgrid div.glyph');
    lcol = 0;
    lrow = 0;
    prv_top = null;
    candidate_count = glyphboxes.length;
    lnr = 0;
    rnr = candidate_count + 1;
    rows = [];
    row = null;
    //.........................................................................................................
    this.log(`index_candidates() (${candidate_count})`);
//.........................................................................................................
    for (idx = i = 0, ref = candidate_count; (0 <= ref ? i < ref : i > ref); idx = 0 <= ref ? ++i : --i) {
      glyphbox = glyphboxes.eq(idx);
      //.......................................................................................................
      if ((nxt_top = glyphbox.offset().top) !== prv_top) {
        if (row != null) {
          rows.push(row);
          col_count = row.length;
          for (col_idx = j = 0, len = row.length; j < len; col_idx = ++j) {
            sub_glyphbox = row[col_idx];
            sub_glyphbox.attr('rcol', col_count - col_idx);
          }
        }
        //.....................................................................................................
        row = [];
        prv_top = nxt_top;
        lcol = 0;
        lrow += +1;
      }
      //.......................................................................................................
      row.push(glyphbox);
      lnr += +1;
      rnr += -1;
      lcol += +1;
      //.......................................................................................................
      glyphbox.attr('lnr', lnr);
      glyphbox.attr('rnr', rnr);
      glyphbox.attr('lcol', lcol);
      glyphbox.attr('lrow', lrow);
    }
    if (row != null) {
      //.........................................................................................................
      rows.push(row);
    }
    row_count = rows.length;
    for (row_idx = k = 0, len1 = rows.length; k < len1; row_idx = ++k) {
      row = rows[row_idx];
      for (l = 0, len2 = row.length; l < len2; l++) {
        glyphbox = row[l];
        glyphbox.attr('rrow', row_count - row_idx);
      }
    }
    //.........................................................................................................
    rows.length = 0/* not strictly needed, just to make de-allocation explicit */
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._select_delta_candidate = function(deltas) {
    var R, delta_key, delta_value, glyphboxes, nxt_cdtsel, nxt_selector, nxt_value, prv_cdtsel, prv_value, type;
    /* Select next candidate(s) based on `deltas`, which should be an object with one or more of the
    following members:

    * **`lnr`**:     left-anchored  candidate         number
    * **`lcol`**:    left-anchored  column            number
    * **`lrow`**:    left-anchored  row (i.e. line)   number
    * **`rnr`**:     right-anchored candidate         number
    * **`rcol`**:    right-anchored column            number
    * **`rrow`**:    right-anchored row (i.e. line)   number

    Left-anchored values count from the usual (i.e. top or left) end of that dimension, richt-anchored ones
    from the opposite sides; for example, `lcol: 1` selects the first (leftmost), `rcol: 1` the last
    (rightmost) entry in each row; `lrow: 1` the first row, `rrow: 1` the last one; in a line with, say, five
    candidates, `lrow: 4` is equivalent to `rrow: 2`, and `lrow: 5` is the same as `rrow: 1`.

    Each entry may be either a positive or negative integer, or zero, or 'first', or 'last'. A non-zero number
    indicates the number of steps to go in the respective dimension while zero indicates 'keep this value'.
    For example, to move right irregardless of line breaks, use `{ lnr: +1, }`. To move to the first entry on
    the next line, use `{ lcol: 'first', lrow: +1, }`. To go to the last entry of the current row, use `{
    lrow: 0, lcol: 'last', }` or `{ lrow: 0, rcol: 'first', }`. The selected candidates are the intersection
    of all sub-selectors.

    This method will have no effect unless there is one or more selected entries to start with.  */
    //.........................................................................................................
    R = 0;
    prv_cdtsel = jQuery('.cdtsel');
    //.........................................................................................................
    if (prv_cdtsel.length === 0) {
      this.log("_select_delta_candidate: no candidate selected");
      return R;
    }
    //.........................................................................................................
    /* TAINT code duplication */
    glyphboxes = jQuery('#candidates-flexgrid div.glyph');
    nxt_selector = [];
//.........................................................................................................
    for (delta_key in deltas) {
      delta_value = deltas[delta_key];
      switch (type = CND.type_of(delta_value)) {
        case 'text':
          switch (delta_value) {
            case 'first':
              nxt_selector.push(`[${delta_key}=1]`);
              break;
            case 'last':
              delta_key = delta_key.replace(/^[rl]/, function($0) {
                if ($0 === 'l') {
                  return 'r';
                } else {
                  return 'l';
                }
              });
              nxt_selector.push(`[${delta_key}=1]`);
              break;
            default:
              throw new Error(`µ37634 unknown move command ${rpr(delta_value)}`);
          }
          break;
        case 'number':
          prv_value = parseInt(prv_cdtsel.attr(delta_key), 10);
          nxt_value = prv_value + delta_value;
          nxt_selector.push(`[${delta_key}=${nxt_value}]`);
          break;
        default:
          throw new Error(`µ37633 expected a text or a number, got a ${type}`);
      }
    }
    nxt_selector = nxt_selector.join('');
    this.log(`_select_delta_candidate ${jr(deltas)} ${jr(nxt_selector)}`);
    if ((R = (nxt_cdtsel = glyphboxes.filter(nxt_selector)).length) === 0) {
      return R;
    }
    prv_cdtsel.removeClass('cdtsel');
    nxt_cdtsel.addClass('cdtsel');
    nxt_cdtsel[0].scrollIntoViewIfNeeded();
    return R;
  };

}).call(this);

//# sourceMappingURL=ops-transcription.js.map
