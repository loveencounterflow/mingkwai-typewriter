// Generated by CoffeeScript 2.3.2
(function() {
  //###########################################################################################################
  var $, $async, CND, FS, KEYS, PATH, PD, STATE, T, XE, alert, badge, debug, help, info, inspect, jr, rpr, urge, warn, whisper, xrpr;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = '明快打字机/OPS';

  debug = CND.get_logger('debug', badge);

  alert = CND.get_logger('alert', badge);

  whisper = CND.get_logger('whisper', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  info = CND.get_logger('info', badge);

  inspect = (require('util')).inspect;

  // TRAP                      = require 'mousetrap'
  KEYS = require('../lib/keys');

  STATE = require('../lib/state');

  T = require('../lib/templates');

  PATH = require('path');

  FS = require('fs');

  //...........................................................................................................
  require('../lib/exception-handler');

  // require                   '../lib/kana-input'
  require('../lib/kanji-input');

  //...........................................................................................................
  PD = require('pipedreams');

  ({jr} = CND);

  ({$, $async} = PD);

  // XE                        = null
  XE = require('../lib/xemitter');

  ({inspect} = require('util'));

  xrpr = function(x) {
    return inspect(x, {
      colors: true,
      breakLength: 2e308,
      maxArrayLength: 2e308,
      depth: 2e308
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  XE.listen_to_all(function(key, d) {
    var S, k, logger, message, toggle, v;
    // whisper 'µ99823', key #, jr d
    v = d.value;
    ({S} = v);
    logger = jQuery('#logger');
    while (logger.children().length > 10) {
      (logger.find(':first-child')).remove();
    }
    message = (function() {
      switch (key) {
        case '^kblevel':
          return ((function() {
            var ref, results;
            ref = S.kblevels;
            results = [];
            for (k in ref) {
              toggle = ref[k];
              if (toggle) {
                results.push(k);
              }
            }
            return results;
          })()).join(', ');
        default:
          return ((function() {
            var results;
            results = [];
            for (k in d.value) {
              results.push(k);
            }
            return results;
          })()).join(', ');
      }
    })();
    logger.append(`<div>${Date.now()}: ${rpr(key)}: ${message}</div>`);
    console.log('µ33499', Date.now(), key, d);
    // if ( kblevels = d.value?.S?.kblevels )
    //   logger.append ( "<div>#{Date.now()}: kblevels: #{rpr kblevels}</div>" )
    logger.scrollTop(logger[0].scrollHeight);
    return null;
  });

  //-----------------------------------------------------------------------------------------------------------
  this.log = function(text) {
    /* TAINT code duplication */
    var logger;
    logger = jQuery('#logger');
    while (logger.children().length > 10) {
      (logger.find(':first-child')).remove();
    }
    /* TAINT should escape text (or accept HTML?) */
    logger.append(`<div>${Date.now()}: ${text}</div>`);
    console.log('µ33499', Date.now(), text);
    logger.scrollTop(logger[0].scrollHeight);
    return null;
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @on_add_selection = ( uie ) ->
  //   { S, } = uie
  //   debug '44545', 'selected row nr:', S.row_idx + 1
  //   chr = S.rows?[ S.row_idx ]?.glyph
  //   XE.emit 'IME/input/add', { S, row_idx: S.row_idx, chr, }
  //   uie.event.preventDefault()
  //   return null

  // #-----------------------------------------------------------------------------------------------------------
  // XE.listen_to 'IME/input/add', @, ( { S, row_idx, chr, } ) ->
  //   debug "update output area"
  //   debug "reset candidates area, input box"
  //   ### TAINT remove buffer ###
  //   S.buffer.push chr
  //   # ( jQuery '#output-area .inbox' ).text S.buffer.join ''
  //   S.codemirror.editor.replaceSelection chr
  //   ( jQuery '#text-input' ).text ''
  //   return null

  //-----------------------------------------------------------------------------------------------------------
  this.on_scroll = (S, event) => {
    var delta_px;
    // if event.originalEvent.deltaY < 0 then  @navigate_vertically S, -1
    // else                                    @navigate_vertically S, +1
    if (S.ignore_next_scroll_events >= 0) {
      S.ignore_next_scroll_events += -1;
      // debug 'scroll', 'discard'
      return true;
    }
    S.ignore_next_scroll_events = 1;
    delta_px = (S.scroller.scrollTop() - S.scroller_last_top) / S.candidates_tr_height;
    S.scroller_last_top = S.scroller.scrollTop();
    // debug 'scroll', delta_px
    // CND.dir event
    // return false if delta_px is 0
    if (delta_px < 0) {
      this.navigate_vertically(S, -1);
    } else {
      this.navigate_vertically(S, +1);
    }
    return false;
  };

  this.on_wheel = (S, event) => {
    if (event.originalEvent.deltaY < 0) {
      this.navigate_vertically(S, -1);
    } else {
      this.navigate_vertically(S, +1);
    }
    return false;
  };

  this.on_vertical_navigation = function(uie) {
    var delta;
    switch (uie.name) {
      case 'up':
        delta = -1;
        break;
      case 'down':
        delta = +1;
        break;
      case 'page-up':
        delta = -10;
        break;
      case 'page-down':
        delta = +10;
    }
    this.navigate_vertically(uie.S, delta);
    uie.event.preventDefault();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.navigate_vertically = function(S, delta) {
    var corrected_row_idx, delta_px, element, element_offset, new_row_idx;
    new_row_idx = S.row_idx + delta;
    corrected_row_idx = Math.max(0, new_row_idx);
    corrected_row_idx = Math.min(S.rows.length - 1, corrected_row_idx);
    //.........................................................................................................
    XE.emit('WINDOW/scroll/vertical', {
      S,
      from: S.row_idx + 1,
      via: new_row_idx + 1,
      to: corrected_row_idx + 1
    });
    //.........................................................................................................
    S.row_idx = corrected_row_idx;
    element = (jQuery('#candidates tr')).eq(S.row_idx);
    if (((element != null ? element.offset : void 0) != null) && ((element_offset = element.offset()) != null)) {
      delta_px = element_offset.top - S.shade_offset_top;
      S.scroller_last_top = S.scroller.scrollTop() + delta_px;
      S.ignore_next_scroll_events += +1;
      S.scroller.scrollTop(S.scroller_last_top);
    }
    // ( ( jQuery element ).find '.glyph' ).css 'font-size', '125%'
    return null;
  };

  // # #-----------------------------------------------------------------------------------------------------------
  // # XE.listen_to 'WINDOW/scroll/vertical', @, ({ S, from, via, to, }) ->
  // #   whisper "WINDOW/scroll/vertical #{from} -> #{via} -> #{to}"

  //-----------------------------------------------------------------------------------------------------------
  XE.listen_to('^candidates', this, function(d) {
    var S, candidate, columns, i, idx, len, nr, ref, rows, v;
    v = d.value;
    ({S} = v);
    if (!S.focus_is_candidates) {
      this.focusframe_to_candidates(S);
    }
    rows = [];
    columns = ['short_iclabel', 'glyph', 'value'];
    ref = v.candidates;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      candidate = ref[idx];
      nr = idx + 1;
      rows.push(T.get_flexgrid_html(candidate));
    }
    // rows.push T.get_row_html [ [ 'nr', nr, ], [ 'glyph', candidate, ] ]
    // rows.push T.get_row_html [ [ 'nr', nr, ], ( [ key, row[ key ], ] for key in columns )..., ]
    rows = rows.join('\n');
    if (true) {
      (jQuery('#candidates-flexgrid div')).remove();
      (jQuery('#candidates-flexgrid')).append(rows);
    } else {
      // @focus_first_candidate S
      (jQuery('#candidates tr')).remove();
      (jQuery('#candidates tbody')).append(rows);
      (jQuery('#qdt')).text(S.qdt);
    }
    return null;
  });

  //-----------------------------------------------------------------------------------------------------------
  XE.listen_to('^load-documents', this, function(d) {
    /* Will be used to restore previous state, open new documents; for now, just opens the default file. */
    /* TAINT auto-create file when not present */
    var file_path;
    file_path = PATH.resolve(PATH.join(__dirname, '../.cache/default.md'));
    d.value.S.codemirror.editor.doc.setValue(FS.readFileSync(file_path, {
      encoding: 'utf-8'
    }));
    return null;
  });

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT use proper keybinding API to define key bindings */
  XE.listen_to('^keyboard', this, function(d) {
    var S, key;
    ({key, S} = d.value);
    if ((key.name === 'ctrl+s') && (key.move === 'up')) {
      XE.emit(PD.new_event('^save-document', {S}));
    }
    return null;
  });

  //-----------------------------------------------------------------------------------------------------------
  XE.listen_to('^save-document', this, function(d) {
    /* Will be used to save active document; currently just saves default file. */
    var file_path;
    file_path = PATH.resolve(PATH.join(__dirname, '../.cache/default.md'));
    this.log(`saving document to ${rpr(file_path)}`);
    FS.writeFileSync(file_path, d.value.S.codemirror.editor.doc.getValue());
    return null;
  });

  //-----------------------------------------------------------------------------------------------------------
  this.focusframe_to_editor = function(S) {
    this._focusframe_to(S, 'leftbar');
    /* TAINT use method, must be possible to remap */
    S.focus_is_candidates = false;
    return S.kblevels.shift = false;
  };

  this.focusframe_to_candidates = function(S) {
    this._focusframe_to(S, 'rightbar');
    /* TAINT use method, must be possible to remap */
    S.focus_is_candidates = true;
    return S.kblevels.shift = false;
  };

  this.focusframe_to_logger = function(S) {
    this._focusframe_to(S, '#logger');
    /* TAINT use method, must be possible to remap */
    S.focus_is_candidates = false;
    return S.kblevels.shift = false;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._focusframe_to = function(S, target) {
    var ff, height, left, tgto, top, width;
    if (CND.isa_text(target)) {
      // target      = jQuery( document.activeElement )
      target = jQuery(target);
    }
    ff = jQuery('focusframe');
    if (target.length < 1) {
      return;
    }
    // ff.offset     target.offset()
    // ff.width      target.width()
    // ff.height     target.height()
    tgto = target.offset();
    if (tgto == null) {
      return;
    }
    left = tgto.left - 1;
    top = tgto.top - 1;
    width = target.width() + 2;
    height = target.height() + 2;
    ff.animate({left, top, width, height}, 100);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT use proper keybinding API to define key bindings */
  XE.listen_to('^kblevel', this, function(d) {
    /* map kblevel 'shift' to manual editor/candidates focus selection */
    var S, v;
    v = d.value;
    ({S} = v);
    // debug 'µ87444', S.kblevels.shift
    if ((S.focus_is_candidates = S.kblevels.shift)) {
      this.focusframe_to_candidates(S);
    } else {
      this.focusframe_to_editor(S);
    }
    /* TAINT consider to re-set focus after mouse clicks to elsewhere in GUI */
    /* Make browser focus always stay on editor: */
    (jQuery('div.CodeMirror-code')).focus();
    return null;
  });

  // #-----------------------------------------------------------------------------------------------------------
  // ### TAINT use proper keybinding API to define key bindings ###
  // XE.listen_to '^keyboard', @, ( d ) ->
  //   { key, S, } = d.value
  //   return unless ( key.move is 'up' )
  //   switch key.name
  //     when 'left'     then  @focusframe_to_editor     S
  //     when 'right'    then  @focusframe_to_candidates S
  //     when 'up'       then  @focusframe_to_editor     S
  //     when 'down'     then  @focusframe_to_logger     S
  //   return null

  //-----------------------------------------------------------------------------------------------------------
  this.init_keymap = function(S) {
    /* TAINT don't define method inside of object */
    var mktw_keymap;
    mktw_keymap = {
      //.......................................................................................................
      'Left': function(cm) {
        if (S.focus_is_candidates) {
          debug('µ77644-1', "cursor movement goes to candidates");
        } else {
          CodeMirror.commands.goCharLeft(cm);
        }
        return null;
      },
      //.......................................................................................................
      'Right': function(cm) {
        if (S.focus_is_candidates) {
          debug('µ77644-2', "cursor movement goes to candidates");
        } else {
          CodeMirror.commands.goCharRight(cm);
        }
        return null;
      },
      //.......................................................................................................
      'Up': function(cm) {
        if (S.focus_is_candidates) {
          debug('µ77644-2', "cursor movement goes to candidates");
        } else {
          CodeMirror.commands.goLineUp(cm);
        }
        return null;
      },
      //.......................................................................................................
      'Down': function(cm) {
        if (S.focus_is_candidates) {
          debug('µ77644-2', "cursor movement goes to candidates");
        } else {
          CodeMirror.commands.goLineDown(cm);
        }
        return null;
      },
      //.......................................................................................................
      'Tab': function(cm) {
        if (S.focus_is_candidates) {
          debug('µ77644-2', "cursor movement goes to candidates");
        } else {
          CodeMirror.commands.defaultTab(cm);
        }
        return null;
      }
    };
    //.........................................................................................................
    S.codemirror.editor.addKeyMap(mktw_keymap);
    // CodeMirror.normalizeKeyMap keyMap.mktw
    // S.codemirror.editor.setOption 'extraKeys', mktw_keymap
    // S.codemirror.commands.foobar = ( cm ) -> debug 'µ46644', 'foobar'
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.init = function() {
    var S;
    // { remote, }               = require 'electron'
    // XE                        = remote.require './xemitter'
    //.........................................................................................................
    /* Instantiate state, add important UI elements */
    S = STATE.new();
    S.candidates = jQuery('#candidates');
    // S.shade_offset_top    = ( jQuery 'shade.foreground' ).offset().top
    // S.scroller            = jQuery 'scroller'
    S.focus_is_candidates = false;
    //.........................................................................................................
    // ### Make sure focus is on input element ###
    // ( jQuery '#text-input' ).focus()
    //.........................................................................................................
    /* TAINT temporary; will use KB event, icon, dedicated method for this */
    /* Switch focus on click on editor */
    // ( jQuery 'leftbar content' ).on 'click', ( event ) =>
    //   if S.codemirror.is_enlarged then  property = { 'height': ( jQuery 'leftbar content' ).css 'min-height' }
    //   else                              property = { 'height': ( jQuery 'leftbar content' ).css 'max-height' }
    //   S.codemirror.is_enlarged = not S.codemirror.is_enlarged
    //   ( jQuery 'leftbar content' ).animate property, 100
    // property = { 'height': ( jQuery 'leftbar content' ).css 'max-height' }
    // ( jQuery 'leftbar content' ).animate property, 100
    // #.........................................................................................................
    // ### Register key and mouse events ###
    // S.scroller.on 'wheel',                ( event ) => @on_wheel                S, event
    // S.scroller.on 'scroll',               ( event ) => @on_scroll               S, event
    // S.input.on 'input',                   ( event ) => @on_input                S, event
    // ### use event for this? ###
    // S.scroller_last_top = S.scroller.scrollTop()
    // #.........................................................................................................
    // ### Measure table row height, adjust shade ###
    // S.candidates_tr_height = ( jQuery '#candidates tr' ).height()
    // ( jQuery 'shade' ).height S.candidates_tr_height * 1.1
    //.........................................................................................................
    /* Initialize CodeMirror */
    S.codemirror.editor = CodeMirror.fromTextArea((jQuery('#codemirror'))[0], S.codemirror.settings);
    S.codemirror.editor.setSize(null, '100%');
    S.codemirror.editor.on('inputRead', function(me, change) {
      return XE.emit(PD.new_event('^raw-input', {S, change}));
    });
    S.codemirror.editor.on('change', function(me, change) {
      if (change.origin !== '+delete') {
        /* TAINT when inserting results, will there be a change event? */
        return null;
      }
      return XE.emit(PD.new_event('^raw-input', {S, change}));
    });
    //.........................................................................................................
    S.codemirror.editor.on('beforeChange', function(me, change) {
      return whisper('µ66653', 'beforeChange', jr(change));
    });
    S.codemirror.editor.on('change', function(me, change) {
      return whisper('µ66653', 'change', jr(change));
    });
    // S.codemirror.editor.on 'changes',         ( me, changes     ) -> whisper 'µ66653', 'changes',       jr changes
    // S.codemirror.editor.on 'cursorActivity',  ( me              ) -> whisper 'µ66653', 'cursorActivity'
    // S.codemirror.editor.on 'keyHandled',      ( me, name, event ) -> whisper 'µ66653', 'keyHandled',    jr name
    // S.codemirror.editor.on 'inputRead',       ( me, change      ) -> whisper 'µ66653', 'inputRead',     jr change
    //.........................................................................................................
    /* Register key and mouse events */
    KEYS.syphon_key_and_mouse_events(S, jQuery('html'));
    // KEYS.register 'axis', 'vertical',     ( uie )   => @on_vertical_navigation  uie
    // KEYS.register 'slot', 'Enter',        ( uie )   => @on_add_selection        uie
    XE.emit(PD.new_event('^load-documents', {S}));
    this.focusframe_to_editor(S);
    this.init_keymap(S);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  jQuery(init.bind(this));

  /*
cm.findPosH(start: {line, ch}, amount: integer, unit: string, visually: boolean) → {line, ch, ?hitSide: boolean}
cm.findPosV(start: {line, ch}, amount: integer, unit: string) → {line, ch, ?hitSide: boolean}
cm.findWordAt(pos: {line, ch}) → {anchor: {line, ch}, head: {line, ch}}
cm.hasFocus() → boolean

doc.addSelection        = (anchor: {line, ch}, ?head: {line, ch})
doc.changeGeneration    = (?closeEvent: boolean) → integer
doc.eachLine            = (f: (line: LineHandle))
doc.eachLine            = (start: integer, end: integer, f: (line: LineHandle))
doc.extendSelection     = (from: {line, ch}, ?to: {line, ch}, ?options: object)
doc.extendSelections    = (heads: array<{line, ch}>, ?options: object)
doc.extendSelectionsBy  = (f: function(range: {anchor, head}) → {line, ch}), ?options: object)
doc.firstLine           = () → integer
doc.getCursor           = (?start: string) → {line, ch}
doc.getExtending        = () → boolean
doc.getLine             = (n: integer) → string
doc.getLineHandle       = (num: integer) → LineHandle
doc.getLineNumber       = (handle: LineHandle) → integer
doc.getRange            = (from: {line, ch}, to: {line, ch}, ?separator: string) → string
doc.getSelection        = (?lineSep: string) → string
doc.getSelections       = (?lineSep: string) → array<string>
doc.getValue            = (?separator: string) → string
doc.isClean             = (?generation: integer) → boolean
doc.lastLine            = () → integer
doc.lineCount           = () → integer
doc.listSelections      = () → array<{anchor, head}>
doc.markClean           = ()
doc.replaceRange        = (replacement: string, from: {line, ch}, to: {line, ch}, ?origin: string)
doc.replaceSelection    = (replacement: string, ?select: string)
doc.replaceSelections   = (replacements: array<string>, ?select: string)
doc.setCursor           = (pos: {line, ch}|number, ?ch: number, ?options: object)
doc.setExtending        = (value: boolean)
doc.setSelection        = (anchor: {line, ch}, ?head: {line, ch}, ?options: object)
doc.setSelections       = (ranges: array<{anchor, head}>, ?primary: integer, ?options: object)
doc.setValue            = (content: string)
doc.somethingSelected   = () → boolean
*/

}).call(this);

//# sourceMappingURL=ops.js.map
