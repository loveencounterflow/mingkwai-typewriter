// Generated by CoffeeScript 2.3.2
(function() {
  /* TAINTs

  * separate:

    * `focus` (a mechanism used by the browser)

    * ?`select`, `choose`? for the action of selecting one particular candidate

    * ??? for what is called `focusframe` now

    these are three different things and should be called different names.

  * accordingly, rename `focusframe` and those `*_focus*` methods that refer to it instead of to browser focus

  * use module-global `S`: this code will only ever run a single input instance; where it does use modules
    that potentially serve several independent consumers, `S` will not be used as argument anyway

  * refactor code into (local) modules

   */
  var $, $async, CND, FS, KEYS, PATH, PD, S, T, XE, after, alert, badge, debug, defer, help, info, inspect, jr, rpr, urge, warn, whisper, xrpr;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = '明快打字机/OPS';

  debug = CND.get_logger('debug', badge);

  alert = CND.get_logger('alert', badge);

  whisper = CND.get_logger('whisper', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  info = CND.get_logger('info', badge);

  inspect = (require('util')).inspect;

  // TRAP                      = require 'mousetrap'
  KEYS = require('../lib/keys');

  T = require('../lib/templates');

  PATH = require('path');

  FS = require('fs');

  //...........................................................................................................
  require('../lib/exception-handler');

  // require                   '../lib/kana-input'
  // require                   '../lib/kanji-input'
  //...........................................................................................................
  PD = require('pipedreams');

  ({jr} = CND);

  ({after} = CND.suspend);

  defer = setImmediate;

  ({$, $async} = PD);

  // XE                        = null
  XE = require('../lib/xemitter');

  ({inspect} = require('util'));

  xrpr = function(x) {
    return inspect(x, {
      colors: true,
      breakLength: 2e308,
      maxArrayLength: 2e308,
      depth: 2e308
    });
  };

  //...........................................................................................................
  S = require('../lib/settings');

  /* module-global configuration and editor state object */  global.S = S;

  //-----------------------------------------------------------------------------------------------------------
  XE.listen_to_all(function(key, d) {
    var logger, message, ref, v;
    // whisper 'µ99823', key #, jr d
    v = (ref = d.value) != null ? ref : {};
    logger = jQuery('#logger');
    while (logger.children().length > 10) {
      (logger.find(':first-child')).remove();
    }
    message = rpr(v);
    // message = ( k for k         of d.value                ).join ', '
    // message = switch key
    //   when '^kblevel' then  ( k for k, toggle of S.kblevels when toggle ).join ', '
    //   else                  ( k for k         of d.value                ).join ', '
    //.........................................................................................................
    logger.append(`<div>${Date.now()}: ${rpr(key)}: ${message}</div>`);
    console.log('µ33499', Date.now(), key, d);
    // if ( kblevels = d.value?.S?.kblevels )
    //   logger.append ( "<div>#{Date.now()}: kblevels: #{rpr kblevels}</div>" )
    logger.scrollTop(logger[0].scrollHeight);
    //.........................................................................................................
    return null;
  });

  //-----------------------------------------------------------------------------------------------------------
  this.log = function(...P) {
    /* TAINT code duplication */
    var logger, p, text;
    text = ((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = P.length; i < len; i++) {
        p = P[i];
        results.push(CND.isa_text(p) ? p : rpr(p));
      }
      return results;
    })()).join(' ');
    logger = jQuery('#logger');
    while (logger.children().length > 10) {
      (logger.find(':first-child')).remove();
    }
    /* TAINT should escape text (or accept HTML?) */
    logger.append(`<div>${Date.now()}: ${text}</div>`);
    console.log('µ33499', Date.now(), text);
    logger.scrollTop(logger[0].scrollHeight);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  XE.listen_to('^candidates', this, function(d) {
    var glyph, glyphboxes, idx, rows, v;
    if (!S.focus_is_candidates) {
      this.focusframe_to_candidates();
    }
    v = d.value;
    rows = ((function() {
      var i, len, ref, results;
      ref = v.candidates;
      results = [];
      for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
        glyph = ref[idx];
        results.push(T.get_flexgrid_html(idx + 1, glyph));
      }
      return results;
    })()).join('\n');
    (jQuery('#candidates-flexgrid div')).remove();
    (jQuery('#candidates-flexgrid')).append(rows);
    //.........................................................................................................
    /* TAINT code duplication */
    glyphboxes = jQuery('#candidates-flexgrid div.glyph');
    glyphboxes.on('click', (e) => {
      var me;
      me = jQuery(e.target);
      /* TAINT code duplication */
      /* TAINT use API to move selection */
      glyphboxes.removeClass('cdtsel');
      me.addClass('cdtsel');
      return this.log(`µ33983-1 ${me.text()} ${jr(me.offset())}`);
    });
    //.........................................................................................................
    this.index_candidates();
    return null;
  });

  //-----------------------------------------------------------------------------------------------------------
  this.index_candidates = function() {
    /* Add or update each candidate `<div class=glyph> with attributes indicating its left- and right-based
    column and row numbers, starting from 1. Elements that match `jQuery '[lrow=1]'` are in the first row from
    the top, while those that match `jQuery '[rrow=1]'` are in the last row from top (first row from the
    bottom). Likewise, `lcol=1`, `rcol=1` match the leftmost and rightmost elements. These indexes have to be
    re-calculated after each container resize event, but simplify the code needed to select single and groups
    of elements. The beauty of the scheme is that we can select e.g. all leftmost elements or all elements
    in the first row (should the need ever arise). */
    /* TAINT code duplication */
    var candidate_count, col_count, col_idx, glyphbox, glyphboxes, i, idx, j, k, l, lcol, len, len1, len2, lnr, lrow, nxt_top, prv_top, ref, rnr, row, row_count, row_idx, rows, sub_glyphbox;
    glyphboxes = jQuery('#candidates-flexgrid div.glyph');
    lcol = 0;
    lrow = 0;
    prv_top = null;
    candidate_count = glyphboxes.length;
    lnr = 0;
    rnr = candidate_count + 1;
    rows = [];
    row = null;
    //.........................................................................................................
    this.log(`index_candidates() (${candidate_count})`);
//.........................................................................................................
    for (idx = i = 0, ref = candidate_count; (0 <= ref ? i < ref : i > ref); idx = 0 <= ref ? ++i : --i) {
      glyphbox = glyphboxes.eq(idx);
      //.......................................................................................................
      if ((nxt_top = glyphbox.offset().top) !== prv_top) {
        if (row != null) {
          rows.push(row);
          col_count = row.length;
          for (col_idx = j = 0, len = row.length; j < len; col_idx = ++j) {
            sub_glyphbox = row[col_idx];
            sub_glyphbox.attr('rcol', col_count - col_idx);
          }
        }
        //.....................................................................................................
        row = [];
        prv_top = nxt_top;
        lcol = 0;
        lrow += +1;
      }
      //.......................................................................................................
      row.push(glyphbox);
      lnr += +1;
      rnr += -1;
      lcol += +1;
      //.......................................................................................................
      glyphbox.attr('lnr', lnr);
      glyphbox.attr('rnr', rnr);
      glyphbox.attr('lcol', lcol);
      glyphbox.attr('lrow', lrow);
    }
    if (row != null) {
      //.........................................................................................................
      rows.push(row);
    }
    row_count = rows.length;
    for (row_idx = k = 0, len1 = rows.length; k < len1; row_idx = ++k) {
      row = rows[row_idx];
      for (l = 0, len2 = row.length; l < len2; l++) {
        glyphbox = row[l];
        glyphbox.attr('rrow', row_count - row_idx);
      }
    }
    //.........................................................................................................
    rows.length = 0/* not strictly needed, just to make de-allocation explicit */
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.insert_space_or_selection = function() {
    /* TAINT this implementation precludes any other functionality that the space bar might be associated
    with in CodeMirror */
    /* TAINT honour multiple selection */
    var cdtsel, text;
    cdtsel = jQuery('.cdtsel');
    text = cdtsel.length > 0 ? cdtsel.text() : ' ';
    S.codemirror.editor.replaceSelection(text);
    this.focusframe_to_editor();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._select_delta_candidate = function(deltas) {
    var R, delta_key, delta_value, glyphboxes, nxt_cdtsel, nxt_selector, nxt_value, prv_cdtsel, prv_value, type;
    /* Select next candidate(s) based on `deltas`, which should be an object with one or more of the
    following members:

    * **`lnr`**:     left-anchored  candidate         number
    * **`lcol`**:    left-anchored  column            number
    * **`lrow`**:    left-anchored  row (i.e. line)   number
    * **`rnr`**:     right-anchored candidate         number
    * **`rcol`**:    right-anchored column            number
    * **`rrow`**:    right-anchored row (i.e. line)   number

    Left-anchored values count from the usual (i.e. top or left) end of that dimension, richt-anchored ones
    from the opposite sides; for example, `lcol: 1` selects the first (leftmost), `rcol: 1` the last
    (rightmost) entry in each row; `lrow: 1` the first row, `rrow: 1` the last one; in a line with, say, five
    candidates, `lrow: 4` is equivalent to `rrow: 2`, and `lrow: 5` is the same as `rrow: 1`.

    Each entry may be either a positive or negative integer, or zero, or 'first', or 'last'. A non-zero number
    indicates the number of steps to go in the respective dimension while zero indicates 'keep this value'.
    For example, to move right irregardless of line breaks, use `{ lnr: +1, }`. To move to the first entry on
    the next line, use `{ lcol: 'first', lrow: +1, }`. To go to the last entry of the current row, use `{
    lrow: 0, lcol: 'last', }` or `{ lrow: 0, rcol: 'first', }`. The selected candidates are the intersection
    of all sub-selectors.

    This method will have no effect unless there is one or more selected entries to start with.  */
    //.........................................................................................................
    R = 0;
    prv_cdtsel = jQuery('.cdtsel');
    //.........................................................................................................
    if (prv_cdtsel.length === 0) {
      this.log("_select_delta_candidate: no candidate selected");
      return R;
    }
    //.........................................................................................................
    /* TAINT code duplication */
    glyphboxes = jQuery('#candidates-flexgrid div.glyph');
    nxt_selector = [];
//.........................................................................................................
    for (delta_key in deltas) {
      delta_value = deltas[delta_key];
      switch (type = CND.type_of(delta_value)) {
        case 'text':
          switch (delta_value) {
            case 'first':
              nxt_selector.push(`[${delta_key}=1]`);
              break;
            case 'last':
              delta_key = delta_key.replace(/^[rl]/, function($0) {
                if ($0 === 'l') {
                  return 'r';
                } else {
                  return 'l';
                }
              });
              nxt_selector.push(`[${delta_key}=1]`);
              break;
            default:
              throw new Error(`µ37634 unknown move command ${rpr(delta_value)}`);
          }
          break;
        case 'number':
          prv_value = parseInt(prv_cdtsel.attr(delta_key), 10);
          nxt_value = prv_value + delta_value;
          nxt_selector.push(`[${delta_key}=${nxt_value}]`);
          break;
        default:
          throw new Error(`µ37633 expected a text or a number, got a ${type}`);
      }
    }
    nxt_selector = nxt_selector.join('');
    this.log(`_select_delta_candidate ${jr(deltas)} ${jr(nxt_selector)}`);
    if ((R = (nxt_cdtsel = glyphboxes.filter(nxt_selector)).length) === 0) {
      return R;
    }
    prv_cdtsel.removeClass('cdtsel');
    nxt_cdtsel.addClass('cdtsel');
    nxt_cdtsel[0].scrollIntoViewIfNeeded();
    return R;
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.always_focus_editor = function() {
    this.always_focus_editor = function()/* do not add any more handlers with this method after first call */ {};
    (jQuery('div.CodeMirror-code')).on('blur', function() {
      return this.focus();
    });
    (jQuery('div.CodeMirror-code')).focus();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._cm_keymap_move = function(cm, editor_method_name, candidates_method) {
    var error;
    try {
      if (!S.focus_is_candidates) {
        return CodeMirror.commands[editor_method_name](cm);
      }
      return candidates_method.apply(this);
    } catch (error1) {
      error = error1;
      alert(`when trying to call \`CodeMirror.commands.${editor_method_name}\`, an error was thrown`);
      throw error;
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT the defaults for cursor moves are taken from
  * public/codemirror/src/edit/commands.js
  * public/codemirror/keymap/sublime.js
  it would be advantageous to derive them somehow from the source or the running instance
   */
  this.move_right = function(cm) {
    return this._cm_keymap_move(cm, 'goCharRight', () => {
      return this._select_delta_candidate({
        lnr: +1
      });
    });
  };

  this.move_left = function(cm) {
    return this._cm_keymap_move(cm, 'goCharLeft', () => {
      return this._select_delta_candidate({
        lnr: -1
      });
    });
  };

  this.move_nxtline_first = function(cm) {
    return this._cm_keymap_move(cm, 'defaultTab', () => {
      return this._select_delta_candidate({
        lcol: 'first',
        lrow: +1
      });
    });
  };

  this.move_prvline_first = function(cm) {
    return this._cm_keymap_move(cm, 'indentLess', () => {
      return this._select_delta_candidate({
        lcol: 'first',
        lrow: -1
      });
    });
  };

  this.move_up = function(cm) {
    return this._cm_keymap_move(cm, 'goLineUp', () => {
      return this.log('######### move_up');
    });
  };

  this.move_down = function(cm) {
    return this._cm_keymap_move(cm, 'goLineDown', () => {
      return this.log('######### move_down');
    });
  };

  this.move_to_home = function(cm) {
    return this._cm_keymap_move(cm, 'goLineStartSmart', () => {
      return this._select_delta_candidate({
        lrow: 0,
        lcol: 'first'
      });
    });
  };

  this.move_to_end = function(cm) {
    return this._cm_keymap_move(cm, 'goLineEnd', () => {
      return this._select_delta_candidate({
        lrow: 0,
        lcol: 'last'
      });
    });
  };

  //===========================================================================================================
  // FOCUSFRAME
  //-----------------------------------------------------------------------------------------------------------
  this.restore_documents = function() {
    /* Will be used to restore previous state, open new documents; for now, just opens the default file. */
    /* TAINT auto-create file when not present */
    var file_path;
    file_path = PATH.resolve(PATH.join(__dirname, '../.cache/default.md'));
    S.codemirror.editor.doc.setValue(FS.readFileSync(file_path, {
      encoding: 'utf-8'
    }));
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.save_document = function() {
    /* Will be used to save active document; currently just saves default file. */
    var file_path;
    file_path = PATH.resolve(PATH.join(__dirname, '../.cache/default.md'));
    this.log(`saving document to ${rpr(file_path)}`);
    FS.writeFileSync(file_path, S.codemirror.editor.doc.getValue());
    return null;
  };

  //===========================================================================================================
  // FOCUSFRAME
  //-----------------------------------------------------------------------------------------------------------
  this.toggle_focusframe = function() {
    // @log "S.focus_is_candidates: #{S.focus_is_candidates}"
    if (S.focus_is_candidates) {
      this.focusframe_to_editor();
    } else {
      this.focusframe_to_candidates();
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.focusframe_to_editor = function() {
    this._focusframe_to('leftbar');
    return S.focus_is_candidates = false;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.focusframe_to_candidates = function() {
    this._focusframe_to('rightbar');
    return S.focus_is_candidates = true;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._focusframe_to = function(target) {
    var ff, height, left, tgto, top, width;
    if (CND.isa_text(target)) {
      // target      = jQuery( document.activeElement )
      target = jQuery(target);
    }
    ff = jQuery('focusframe');
    if (target.length < 1) {
      return;
    }
    // ff.offset     target.offset()
    // ff.width      target.width()
    // ff.height     target.height()
    tgto = target.offset();
    if (tgto == null) {
      return;
    }
    left = tgto.left - 1;
    top = tgto.top - 1;
    width = target.width() + 2;
    height = target.height() + 2;
    ff.animate({left, top, width, height}, 100);
    return null;
  };

  //===========================================================================================================
  // MENU BAR
  //-----------------------------------------------------------------------------------------------------------
  this.show_or_hide_menu_bar = function() {
    var remote, w;
    ({remote} = require('electron'));
    w = remote.getCurrentWindow();
    w.setMenuBarVisibility(!w.isMenuBarVisible());
    return null;
  };

  //===========================================================================================================
  // INPUT TRANSLATION
  //-----------------------------------------------------------------------------------------------------------
  this.set_translation_mark = function(position_from, position_to) {
    var settings;
    settings = {
      className: 'txtmark_xxx',
      inclusiveLeft: false,
      inclusiveRight: true
    };
    return S.codemirror.editor.markText(position_from, position_to, settings);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.set_translation_mode = function(xxx) {};

  //-----------------------------------------------------------------------------------------------------------
  XE.listen_to('^raw-input', function(d) {
    var change, cursor, doc, editor, line_handle, line_idx, line_info, text/* TAINT consider to use line_idx, forego line_handle */;
    /* Transform `^raw-input` to `^input` events */
    //.........................................................................................................
    ({change} = d.value);
    ({editor} = S.codemirror);
    ({doc} = editor);
    cursor = doc.getCursor();
    //.........................................................................................................
    /* TAINT kludge to collapse multiple selections into a single one */
    CodeMirror.commands.singleSelection(editor);
    //.........................................................................................................
    line_idx = cursor.line;
    line_handle = doc.getLineHandle(line_idx);
    line_info = doc.lineInfo(line_handle);
    ({text} = line_info);
    //.........................................................................................................
    XE.emit(PD.new_event('^input', {change, line_idx, text}));
    return null;
  });

  //===========================================================================================================
  // KEY BINDINGS
  //-----------------------------------------------------------------------------------------------------------
  this.set_codemirror_keybindings = function() {
    var mktw_keymap;
    mktw_keymap = {
      'Left': (cm) => {
        return this.move_left(cm);
      },
      'Right': (cm) => {
        return this.move_right(cm);
      },
      'Up': (cm) => {
        return this.move_up(cm);
      },
      'Down': (cm) => {
        return this.move_down(cm);
      },
      'Tab': (cm) => {
        return this.move_nxtline_first(cm);
      },
      'Shift-Tab': (cm) => {
        return this.move_prvline_first(cm);
      },
      'Home': (cm) => {
        return this.move_to_home(cm);
      },
      'End': (cm) => {
        return this.move_to_end(cm);
      },
      'Space': (cm) => {
        return this.insert_space_or_selection(cm);
      }
    };
    //.........................................................................................................
    S.codemirror.editor.addKeyMap(mktw_keymap);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.set_app_keybindings = function() {
    KEYS.bind('alt', this, this.show_or_hide_menu_bar);
    KEYS.bind('shift', this, this.toggle_focusframe);
    KEYS.bind('ctrl+s', this, this.save_document);
    return null;
  };

  //===========================================================================================================
  // APP INITIALIZATION
  //-----------------------------------------------------------------------------------------------------------
  this.init = function() {
    // { remote, }               = require 'electron'
    // XE                        = remote.require './xemitter'
    //.........................................................................................................
    S.candidates = {
      jq: jQuery('#candidates'),
      selected: {
        id: null
      }
    };
    S.focus_is_candidates = false;
    //.........................................................................................................
    /* Initialize CodeMirror */
    S.codemirror.editor = CodeMirror.fromTextArea((jQuery('#codemirror'))[0], S.codemirror.settings);
    S.codemirror.editor.setSize(null, '100%');
    S.codemirror.editor.on('inputRead', function(me, change) {
      return XE.emit(PD.new_event('^raw-input', {change}));
    });
    XE.listen_to('^ignore-delete', function() {
      return S.ignore_delete += +1;
    });
    S.codemirror.editor.on('change', function(me, change) {
      if (change.origin !== '+delete') {
        /* TAINT when inserting results, will there be a change event? */
        return null;
      }
      /* ignore event if it has been generated: */
      if (S.ignore_delete > 0) {
        S.ignore_delete += -1;
        return null;
      }
      return XE.emit(PD.new_event('^raw-input', {change}));
    });
    this.always_focus_editor();
    //.........................................................................................................
    // S.codemirror.editor.on 'beforeChange',    ( me, change      ) -> whisper 'µ66653', 'beforeChange',  jr change
    // S.codemirror.editor.on 'change',          ( me, change      ) -> whisper 'µ66653', 'change',        jr change
    // S.codemirror.editor.on 'changes',         ( me, changes     ) -> whisper 'µ66653', 'changes',       jr changes
    // S.codemirror.editor.on 'cursorActivity',  ( me              ) -> whisper 'µ66653', 'cursorActivity'
    // S.codemirror.editor.on 'keyHandled',      ( me, name, event ) -> whisper 'µ66653', 'keyHandled',    jr name
    // S.codemirror.editor.on 'inputRead',       ( me, change      ) -> whisper 'µ66653', 'inputRead',     jr change
    //.........................................................................................................
    /* Register key and mouse events */
    KEYS.generate_keboard_events(jQuery('html'));
    // KEYS.register 'axis', 'vertical',     ( uie )   => @on_vertical_navigation  uie
    // KEYS.register 'slot', 'Enter',        ( uie )   => @on_add_selection        uie
    this.restore_documents();
    this.focusframe_to_editor();
    this.set_codemirror_keybindings();
    this.set_app_keybindings();
    //.........................................................................................................
    /* Detect resizing events: */
    /* TAINT won't work when panes are shifted (probably) */
    (jQuery(window)).on('resize', () => {
      debug("resize window");
      this.index_candidates();
      return null;
    });
    return null;
  };

  //###########################################################################################################
  jQuery(init.bind(this));

  /*
cm.findPosH(start: {line, ch}, amount: integer, unit: string, visually: boolean) → {line, ch, ?hitSide: boolean}
cm.findPosV(start: {line, ch}, amount: integer, unit: string) → {line, ch, ?hitSide: boolean}
cm.findWordAt(pos: {line, ch}) → {anchor: {line, ch}, head: {line, ch}}
cm.hasFocus() → boolean

doc.addSelection        = (anchor: {line, ch}, ?head: {line, ch})
doc.changeGeneration    = (?closeEvent: boolean) → integer
doc.eachLine            = (f: (line: LineHandle))
doc.eachLine            = (start: integer, end: integer, f: (line: LineHandle))
doc.extendSelection     = (from: {line, ch}, ?to: {line, ch}, ?options: object)
doc.extendSelections    = (heads: array<{line, ch}>, ?options: object)
doc.extendSelectionsBy  = (f: function(range: {anchor, head}) → {line, ch}), ?options: object)
doc.firstLine           = () → integer
doc.getCursor           = (?start: string) → {line, ch}
doc.getExtending        = () → boolean
doc.getLine             = (n: integer) → string
doc.getLineHandle       = (num: integer) → LineHandle
doc.getLineNumber       = (handle: LineHandle) → integer
doc.getRange            = (from: {line, ch}, to: {line, ch}, ?separator: string) → string
doc.getSelection        = (?lineSep: string) → string
doc.getSelections       = (?lineSep: string) → array<string>
doc.getValue            = (?separator: string) → string
doc.isClean             = (?generation: integer) → boolean
doc.lastLine            = () → integer
doc.lineCount           = () → integer
doc.listSelections      = () → array<{anchor, head}>
doc.markClean           = ()
doc.replaceRange        = (replacement: string, from: {line, ch}, to: {line, ch}, ?origin: string)
doc.replaceSelection    = (replacement: string, ?select: string)
doc.replaceSelections   = (replacements: array<string>, ?select: string)
doc.setCursor           = (pos: {line, ch}|number, ?ch: number, ?options: object)
doc.setExtending        = (value: boolean)
doc.setSelection        = (anchor: {line, ch}, ?head: {line, ch}, ?options: object)
doc.setSelections       = (ranges: array<{anchor, head}>, ?primary: integer, ?options: object)
doc.setValue            = (content: string)
doc.somethingSelected   = () → boolean
*/

}).call(this);

//# sourceMappingURL=ops.js.map
